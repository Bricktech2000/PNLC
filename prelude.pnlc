# vim:tw=80:ft=pnlc:
.\p .p \x \f .f x \def

..def \x x \id
..def \x \y x \kestrel
..def \x \y y \kite
..def \x \f .f x \thrush
..def \x \y \f ..f x y \vireo
..def \f \x ..f x x \mockingbird
..def \f \x \y ..f y x \cardinal
..def \f \g \x .f .g x \bluebird
..def \f \g \x \y .f ..g x y \blackbird
..def \f \x \g \y ..f x .g y \dove
..def \f \g \h \x ..f .g x .h x \phi
..def \f \g \x \y ..f .g x .g y \psi
..def \f .\x .f .x x \x .f .x x \fix

 # constructors and eliminators

..def $err \void
..def \x x \unit

# def:bool
..def \true \false true \true
..def \true \false false \false
..def \bool ..bool false true \not
..def \rhs \lhs ..rhs lhs rhs \and
..def \rhs \lhs ..rhs rhs lhs \or
..def \rhs \lhs ...rhs not id lhs \xor

# def:cmp
..def \lt \et \gt lt \lt
..def \lt \et \gt et \et
..def \lt \et \gt gt \gt
..def \cmp ...cmp true false false \islt
..def \cmp ...cmp false true false \iseq
..def \cmp ...cmp false false true \isgt

# def:opt
..def \opt \some \none .some opt \some
..def \some \none none \none
..def \opt ..opt .kestrel true false \issome
..def \opt ..opt .kestrel false true \isnone
..def \opt ..opt id $err \unwrap

# def:nat
..def \nat \succ \zero .succ nat \succ
..def \succ \zero zero \zero
..def \nat ..nat .kestrel true false \issucc
..def \nat ..nat .kestrel false true \iszero
..def \nat ..nat id $err \pred
..def \func \zero .fix \ind \nat ..nat ind zero \ind

..def \fst \snd \pair ..pair fst snd \pair
..def \pair .pair \fst \snd fst \fst
..def \pair .pair \fst \snd snd \snd

# def:list
..def \head \tail \cons \nil ..cons head tail \cons
..def \cons \nil nil \nil
..def \list ..list \head \tail true false \iscons
..def \list ..list \head \tail false true \isnil
..def \list ..list \head \tail .some head none \head
..def \list ..list \head \tail .some tail none \tail

# type Arr8 a = (a, a, a, a, a, a, a, a)
..def \0 \1 \2 \3 \4 \5 \6 \7 \arr8 ........arr8 0 1 2 3 4 5 6 7 \arr8
..def \arr8 .arr8 \0 \1 \2 \3 \4 \5 \6 \7 0 \arr8.0
..def \arr8 .arr8 \0 \1 \2 \3 \4 \5 \6 \7 1 \arr8.1
..def \arr8 .arr8 \0 \1 \2 \3 \4 \5 \6 \7 2 \arr8.2
..def \arr8 .arr8 \0 \1 \2 \3 \4 \5 \6 \7 3 \arr8.3
..def \arr8 .arr8 \0 \1 \2 \3 \4 \5 \6 \7 4 \arr8.4
..def \arr8 .arr8 \0 \1 \2 \3 \4 \5 \6 \7 5 \arr8.5
..def \arr8 .arr8 \0 \1 \2 \3 \4 \5 \6 \7 6 \arr8.6
..def \arr8 .arr8 \0 \1 \2 \3 \4 \5 \6 \7 7 \arr8.7

 # typeclass definitions

..def \equal \eq .eq equal \eq
..def \eq .eq \equal equal \equal
..def \eq .eq \equal ..blackbird not equal \unequal

..def \eq \compare \ord ..ord eq compare \ord
..def \ord .ord \eq \compare eq \ord:eq
..def \ord .ord \eq \compare compare \compare
..def \ord \rhs \lhs .eq
  ......compare ord rhs lhs false true false
\ord.eq
# return the left-hand side when the arguments compare equal
..def \ord \rhs \lhs ......compare ord rhs lhs rhs lhs lhs \min
..def \ord \rhs \lhs ......compare ord rhs lhs lhs lhs rhs \max
..def \ord \sgrp .sgrp .min ord \min:sgrp
..def \ord \sgrp .sgrp .max ord \max:sgrp
..def \ord \bndd \mnid .bndd \top \bot
  ..mnid .min:sgrp ord top
\min:mnid
..def \ord \bndd \mnid .bndd \top \bot
  ..mnid .max:sgrp ord bot
\max:mnid
# return the argument when it is equal to one or both bounds
..def \ord \bounds .bounds \lo \hi ..bluebird ..min ord hi ..max ord lo \clamp

..def \top \bot \bndd ..bndd top bot \bndd
..def \bndd .bndd \top \bot top \top
..def \bndd .bndd \top \bot bot \bot

..def \sappend \sgrp .sgrp sappend \sgrp
..def \sgrp .sgrp \sappend sappend \sappend
# dual semigroup, the semigroup obtained by swapping arguments to `sappend`
..def \inner:sgrp .inner:sgrp \sappend .sgrp .cardinal sappend \dual:sgrp
# XXX binary exponentiation?
..def \sgrp \elem \count
  ...ind ..sappend sgrp elem elem count
\stimes

..def \sgrp \mempty \mnid ..mnid sgrp mempty \mnid
..def \mnid .mnid \sgrp \mempty sgrp \mnid:sgrp
..def \mnid .mnid \sgrp \mempty mempty \mempty
# dual monoid, the monoid obtained by swapping arguments to `sappend`
..def \inner:mnid .inner:mnid \sgrp .mnid .dual:sgrp sgrp \dual:mnid
..def \mnid \elem \count .mnid \sgrp \mempty
  ..count ..stimes sgrp elem mempty
\mtimes

..def \fmap \ftor .ftor fmap \ftor
..def \ftor .ftor \fmap fmap \fmap
..def \ftor ..bluebird .fmap ftor kestrel \fmapk

..def \ftor \pure \apply \appl ...appl ftor pure apply \appl
..def \appl .appl \ftor \pure \apply ftor \appl:ftor
..def \appl .appl \ftor \pure \apply pure \pure
..def \appl .appl \ftor \pure \apply apply \apply
..def \appl \func \fst \snd
  ...apply appl
    ...fmap .appl:ftor appl func fst
    snd
\lifta2
..def \appl ..lifta2 appl thrush \rapply
# XXX why are these two so slow?
..def \appl ..lifta2 appl kestrel \seql
..def \appl ..lifta2 appl kite \seqr
..def \appl \left \right \inner
  ...seqr appl left ...seql appl inner right
\between
# `(Applicative f, Monoid a) => Monoid (Ap f a)` by lifting the monoid pointwise
..def \appl \inner:sgrp .inner:sgrp \innersappend
  .sgrp ..lifta2 appl innersappend
\ap:sgrp
..def \appl \inner:mnid .inner:mnid \inner:sgrp \innermempty
  ..mnid
    ..ap:sgrp appl inner:sgrp
    ..pure appl innermempty
\ap:mnid

..def \appl \bind \monad ..monad appl bind \monad
..def \monad .monad \appl \bind appl \monad:appl
..def \monad .monad \appl \bind bind \bind
..def \monad \x \f ...bind monad x .kestrel f \bindk
..def \monad \f \g \x ...bind monad .f x g \kleisli
# the monoid of Kleisli endomorphisms under Kleisli composition
..def \monad .sgrp .kleisli monad \kendo:sgrp
..def \monad ..mnid .kendo:sgrp monad .pure .monad:appl monad \kendo:mnid

..def \appl \empty \alt \altn ...altn appl empty alt \altn
..def \altn .altn \appl \empty \alt appl \altn:appl
..def \altn .altn \appl \empty \alt empty \empty
..def \altn .altn \appl \empty \alt alt \alt
..def \many1 \altn \val
  ...alt altn ..many1 altn val ..pure .altn:appl altn nil
\many
..def \many \altn \val
  ....lifta2 .altn:appl altn cons val ..many altn val
\many1
..def .fix ..bluebird many1 many
..def .fix ..bluebird many many1
\many \many1
..def \altn \sep \elem
  ....lifta2 .altn:appl altn cons
    elem
    ..many altn ...seqr .altn:appl altn sep elem
\sepby1
..def \altn \sep \elem
  ...alt altn
    ...sepby1 altn sep elem
    ..pure .altn:appl altn nil
\sepby
# the monoid induced by `alt`
..def \altn .sgrp .alt altn \alt:sgrp
..def \altn ..mnid alt:sgrp .empty altn \alt:mnid

 # utility functions and typeclass instances

# the left-zero and right-zero semigroups over the carrier set
..def .sgrp kite \first:sgrp
..def .sgrp kestrel \last:sgrp
# the monoid of endomorphisms under composition
..def .sgrp bluebird \endo:sgrp
..def ..mnid endo:sgrp id \endo:mnid
# `Monoid b => Monoid (a -> b)` by combining return values
..def \ret:sgrp .ret:sgrp \retsappend
  .sgrp \rhs \lhs \arg ..retsappend .rhs arg .lhs arg
\func:sgrp
..def \ret:mnid .ret:mnid ..bluebird mnid func:sgrp \func:mnid

..def .eq \rhs \lhs true \unit:eq
..def .eq \rhs \lhs void \void:eq
..def ..ord unit:eq \rhs \lhs et \unit:ord
..def ..ord void:eq \rhs \lhs void \void:ord
..def ..bndd unit unit \unit:bndd
..def ..bndd void void \void:bndd
..def .sgrp \rhs \lhs void \void:sgrp
..def .sgrp \rhs \lhs unit \unit:sgrp
..def ..mnid void:sgrp void \void:mnid
..def ..mnid unit:sgrp unit \unit:mnid

..def .eq
  \rhs \lhs ..rhs
    ..lhs true false
    ..lhs false true
\bool:eq
..def ..ord
  bool:eq
  \rhs \lhs ..rhs
    ..lhs et lt
    ..lhs gt et
\bool:ord
..def ..bndd true false \bool:bndd
# XXX duplicates of `.bool:ord min:sgrp` and `.bool:bndd .bool:ord min:mnid`
# XXX duplicates of `.bool:ord max:sgrp` and `.bool:bndd .bool:ord max:mnid`
..def .sgrp and \and:sgrp
..def .sgrp or \or:sgrp
..def .sgrp xor \xor:sgrp
..def ..mnid and:sgrp true \and:mnid
..def ..mnid or:sgrp false \or:mnid
..def ..mnid xor:sgrp false \xor:mnid

..def .eq
  \rhs \lhs ...rhs
    ...lhs true false false
    ...lhs false true false
    ...lhs false false true
\cmp:eq
..def ..ord
  cmp:eq
  \rhs \lhs ...rhs
    ...lhs et gt gt
    ...lhs lt et gt
    ...lhs lt lt et
\cmp:ord
..def ..bndd gt lt \cmp:bndd
..def .sgrp \rhs \lhs ...lhs lhs rhs lhs \cmp:sgrp
..def ..mnid cmp:sgrp et \cmp:mnid
# the reverse ordering, obtained by swapping arguments to `compare`
..def \inner:ord .inner:ord \innereq \innercompare
  ..ord innereq .cardinal innercompare
\down:ord
# the reverse bounding, obtained by swapping `top` and `bot`
..def \inner:bndd .inner:bndd \innertop \innerbot
  ..bndd innertop innerbot
\down:bndd

..def .ftor
  \func \optarg
    ..optarg \arg .some .func arg none
\opt:ftor
..def ...appl
  opt:ftor
  some
  \optfunc \optarg
    ..optfunc \func ...fmap opt:ftor func optarg none
\opt:appl
..def ..monad
  opt:appl
  \optarg \func ..optarg func none
\opt:monad
..def ...altn
  opt:appl
  none
  \optrhs \optlhs ..optlhs some optrhs
\opt:altn
# `Semigroup a => Monoid (Maybe a)` by adjoining `Nothing` as neutral element
..def \inner:sgrp .inner:sgrp \innersappend
  .sgrp
    \optrhs \optlhs ..optrhs
      \rhs ...fmap opt:ftor .innersappend rhs optlhs
      optlhs
\optsgrp:sgrp
..def \inner:sgrp ..mnid .optsgrp:sgrp inner:sgrp none \optsgrp:mnid
# no need for `Data.Monoid.First a`, it'd be isomorphic to `Alt Maybe a` and to
# `Semigroup b => Modoid (Maybe b)` for `b ~ Data.Semigroup.First a`.
# no need for `Data.Monoid.Last a`, it'd be isomorphic to `Dual (Alt Maybe a)`
# and to `Semigroup b => Modoid (Maybe b)` for `b ~ Data.Semigroup.Last a`.
#
# these typeclass instances need to be lazy in the element typeclass instance so
# we can take their fixed points to define the equivalent instances for `nat`
..def \elem:eq .eq
  \rhs \lhs ..rhs
    ..lhs .cardinal .equal elem:eq .kestrel false
    ..lhs .kestrel false true
\opt:eq
..def \elem:ord ..ord
  .opt:eq .ord:eq elem:ord
  \rhs \lhs ..rhs
    ..lhs .cardinal .compare elem:ord .kestrel lt
    ..lhs .kestrel gt et
\opt:ord
..def \elem:bndd ..bndd .some .top elem:bndd none \opt:bndd
# `type Every a = Down (Maybe (Down a))`
# the ordering where `Nothing` is the top element instead of the bottom element
..def \elem:ord .down:ord .opt:ord .down:ord elem:ord \every:ord
..def \elem:bndd .down:bndd .opt:bndd .down:bndd elem:bndd \every:bndd

..def \rhs \lhs ...ind succ lhs rhs \add
..def \rhs \lhs ...ind .add lhs zero rhs \mul
..def \rhs \lhs ...ind .mul lhs .succ zero rhs \exp
..def \rhs \lhs ...ind ..cardinal exp lhs .succ zero rhs \tet
..def .sgrp add \add:sgrp
..def .sgrp mul \mul:sgrp
..def ..mnid add:sgrp zero \add:mnid
..def ..mnid mul:sgrp .succ zero \mul:mnid
..def opt:ftor \nat:ftor
..def opt:appl \nat:appl
..def opt:altn \nat:altn
..def opt:monad \nat:monad
..def .fix opt:eq \nat:eq
..def .fix opt:ord \nat:ord
..def .fix opt:bndd \nat:bndd # zero, fix succ

# XXX doc wrappers? currently:
#   - ap
#   - min
#   - max
#   - add
#   - sqr
#   - swap
#   - endo
#   - kendo
#   - dual
#   - down
#   - every

# TODO doc conventions:
#   - \rhs \lhs, for partial application
#   - meanings of :
#     --> swap:mnid means 'monoid under swap' whereas
#         and:mnid means 'monoid induced by `and`'
#   - terse typeclass names because manual resolution

..def \fst:eq \snd:eq .fst:eq \fstequal .snd:eq \sndequal
    .eq
      \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
        ...sappend and:sgrp # and
          ..sndequal rhssnd lhssnd
          ..fstequal rhsfst lhsfst
\pair:eq
..def \fst:ord \snd:ord
  .fst:ord \fst:eq \fstcompare .snd:ord \snd:eq \sndcompare
    ..ord
      ..pair:eq fst:eq snd:eq
      \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
        ...sappend cmp:sgrp
          ..sndcompare rhssnd lhssnd
          ..fstcompare rhsfst lhsfst
\pair:ord
..def \fst:bndd \snd:bndd .fst:bndd \fsttop \fstbot .snd:bndd \sndtop \sndbot
    ..bndd
      ..pair fsttop sndtop
      ..pair fstbot sndbot
\pair:bndd
..def \fst:sgrp \snd:sgrp .fst:sgrp \fstsappend .snd:sgrp \sndsappend
    .sgrp
      \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
        ..pair
          ..fstsappend rhsfst lhsfst
          ..sndsappend rhssnd lhssnd
\pair:sgrp
..def \fst:mnid \snd:mnid
  .fst:mnid \fst:sgrp \fstmempty .snd:mnid \snd:sgrp \sndmempty
    ..mnid
      ..pair:sgrp fst:sgrp snd:sgrp
      ..pair fstmempty sndmempty
\pair:mnid
..def .ftor \sndfunc \pairarg
  .pairarg \fstarg \sndarg
    ..pair fstarg .sndfunc sndarg
\pair:ftor
..def \fst:mnid .fst:mnid \fst:sgrp \fstmempty .fst:sgrp \fstsappend
    ...appl
      pair:ftor
      \sndarg ..pair fstmempty sndarg
      \pairfunc \pairarg .pairfunc \fstfunc \sndfunc .pairarg \fstarg \sndarg
        ..pair ..fstsappend fstarg fstfunc .sndfunc sndarg
\pair:appl
..def \fst:mnid .fst:mnid \fst:sgrp \fstmempty .fst:sgrp \fstsappend
    ..monad
      .pair:appl fst:mnid
      \pairarg \sndfunc .pairarg \fstarg \sndarg
        ..sndfunc sndarg \fstret \sndret
          ..pair ..fstsappend fstret fstarg sndret
\pair:monad
..def \pair ..bluebird pair cardinal \swap

# type Swap a b = (b, a)
#
# the ordering obtained by swapping elements of the pair ordering
..def \snd:eq \fst:eq
  .eq
    \rhs \lhs
      ....pair:eq snd:eq fst:eq
        .swap rhs
        .swap lhs
\swap:eq
..def \snd:ord \fst:ord
  .snd:ord \snd:eq \sndcompare .fst:ord \fst:eq \fstcompare
    ..ord
      ..swap:eq snd:eq fst:eq
      \rhs \lhs
        ....pair:ord snd:ord fst:ord
          .swap rhs
          .swap lhs
\swap:ord
# the bounding obtained by swapping elements of the pair bounding
..def \snd:bndd \fst:bndd
  ..pair:bndd snd:bndd fst:bndd
\swap:bndd
# the monad obtained by swapping elements of the pair monad
..def .ftor
  \fstfunc \pairarg .swap
    ...fmap pair:ftor fstfunc
      .swap pairarg
\swap:ftor
..def \snd:mnid
  ...appl
    swap:ftor
    \fstarg .swap
      ..pure .pair:appl snd:mnid
        fstarg
    \pairfunc \pairarg .swap
      ...apply .pair:appl snd:mnid
        .swap pairfunc
        .swap pairarg
\swap:appl
..def \snd:mnid
  ..monad
    .swap:appl snd:mnid
    \pairarg \fstfunc .swap
      ...bind .pair:monad snd:mnid
        .swap pairarg
        ..bluebird swap fstfunc
\swap:monad

# type Sqr a = (a, a)
..def .mockingbird pair:eq \sqr:eq
..def .mockingbird pair:ord \sqr:ord
..def .mockingbird pair:bndd \sqr:bndd
# no need for `Monoid a => Monoid (Sqr a)`, it'd be isomorphic to
# `(Applicative f, Monoid a) => Monoid (Ap f a)` for `f ~ Sqr`
..def .ftor
  \func \sqrarg .sqrarg \fstarg \sndarg
    ..pair .func fstarg .func sndarg
\sqr:ftor
..def ...appl
  sqr:ftor
  \arg ..pair arg arg
  \sqrfunc \sqrarg .sqrfunc \fstfunc \sndfunc .sqrarg \fstarg \sndarg
    ..pair .fstfunc fstarg .sndfunc sndarg
\sqr:appl
..def ..monad
  sqr:appl
  \sqrarg \func .sqrarg \fstarg \sndarg
    ..pair .fst .func fstarg .snd .func sndarg
\sqr:monad
..def \func \zero \sqr
  .sqr \fst \snd ..func ..func zero fst snd
\sqr.foldl # XXX foldable
..def \func \zero \sqr
  .sqr \fst \snd ..func fst ..func snd zero
\sqr.foldr # XXX foldable
..def \elem:appl
  ..sqr.foldl
    .apply appl
    ..pure elem:appl pair
\sqr.sequence # XXX support anything `traversable`

# TODO instance ord
# TODO instance bounded
# TODO instance `Down (List (Down a))`, see every:ord and every:bndd
..def .fix \list.foldl \func \zero \list
  ..list
    \head \tail ...list.foldl func ..func zero head tail
    zero
\list.foldl # XXX foldable
..def .fix \list.foldr \func \zero \list
  ..list
    \head \tail ..func head ...list.foldr func zero tail
    zero
\list.foldr # XXX foldable
..def ..list.foldr .kestrel succ zero \length
..def ..list.foldl .cardinal cons nil \list.reverse
..def ..list.foldr \elem \acc .some ..acc id elem none \last
..def ..list.foldr \elem \acc .some ..acc .cons elem nil none \init
..def \elem:appl
  ..list.foldr ..lifta2 elem:appl cons ..pure elem:appl nil
\list.sequence # XXX support anything `traversable`
# no need for `Monoid [a]`, it'd be isomorphic to `Alternative f =>
# Monoid (Alt f a)` for `f ~ []`
..def .ftor
  \func ..list.foldr ..bluebird cons func nil
\list:ftor
..def ...appl
  list:ftor
  \arg ..cons arg nil
  \listfunc \listarg ...list.foldr
    \func \acc ...list.foldr ..bluebird cons func acc listarg
    nil
    listfunc
\list:appl
..def ..monad
  list:appl
  \listarg \func ...list.foldr
    \arg \acc ...list.foldr cons acc .func arg
    nil
    listarg
\list:monad
..def ...altn
  list:appl
  nil
  .list.foldr cons
\list:altn

..def .ftor
  \func \arg8
    .arg8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ........arr8
        .func a0
        .func a1
        .func a2
        .func a3
        .func a4
        .func a5
        .func a6
        .func a7
\arr8:ftor
..def ...appl
  arr8:ftor
  \arg ........arr8 arg arg arg arg arg arg arg arg
  \func8 \arg8
    .func8 \f0 \f1 \f2 \f3 \f4 \f5 \f6 \f7
      .arg8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
        ........arr8
          .f0 a0
          .f1 a1
          .f2 a2
          .f3 a3
          .f4 a4
          .f5 a5
          .f6 a6
          .f7 a7
\arr8:appl
..def ..monad
  arr8:appl
  \arg8 \func
    .arg8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ........arr8
        .arr8.0 .func a0
        .arr8.1 .func a1
        .arr8.2 .func a2
        .arr8.3 .func a3
        .arr8.4 .func a4
        .arr8.5 .func a5
        .arr8.6 .func a6
        .arr8.7 .func a7
\arr8:monad
..def \func \zero \arr8
  .arr8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    ..func
      ..func
        ..func
          ..func
            ..func
              ..func
                ..func
                  ..func
                    zero
                    a0
                  a1
                a2
              a3
            a4
          a5
        a6
      a7
\arr8.foldl # XXX foldable
..def \func \zero \arr8
  .arr8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    ..func a0
      ..func a1
        ..func a2
          ..func a3
            ..func a4
              ..func a5
                ..func a6
                  ..func a7
                    zero
\arr8.foldr # XXX foldable
..def ..arr8.foldr thrush arr8 \arr8.reverse
..def \elem:appl .elem:appl \elem:ftor \elempure \elemapply
  ..arr8.foldl elemapply .elempure arr8
\arr8.sequence # XXX support anything `traversable`
..def \elem:eq .elem:eq \elemequal
  .eq
    ..blackbird
      # XXX use `.and:mnid .arr8:fldb fold` instead
      ..arr8.foldr and true
      ..lifta2 arr8:appl elemequal
\arr8:eq # XXX support anything `foldable`
..def \elem:ord .elem:ord \elem:eq \elemcompare
  ..ord
    .arr8:eq elem:eq
    ..blackbird
      # XXX use `.cmp:mnid .arr8:fldb fold` instead
      ..arr8.foldr .sappend cmp:sgrp et
      ..lifta2 arr8:appl elemcompare
\arr8:ord # XXX support anything `foldable`
..def \elem:bndd .elem:bndd \elemtop \elembot
  ..bndd
    ..pure arr8:appl elemtop
    ..pure arr8:appl elembot
\arr8:bndd

# type U8 = Arr8 Bool = (Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool)
..def ........arr8 false false false false false false false false \'\0'u8
..def ........arr8 false false true  true  true  true  true  false \'|'u8
..def ........arr8 false true  true  true  true  true  false false \'>'u8
..def ........arr8 false false true  true  true  true  false false \'<'u8
..def ........arr8 true  true  false true  false true  false false \'+'u8
..def ........arr8 true  false true  true  false true  false false \'-'u8
..def ........arr8 false true  true  true  false true  false false \'.'u8
..def ........arr8 false false true  true  false true  false false \','u8
..def ........arr8 true  true  false true  true  false true  false \'['u8
..def ........arr8 true  false true  true  true  false true  false \']'u8
..def ........arr8 true  false false false false true  false false \'!'u8
..def ........arr8 false true  true  true  true  true  false false \'>'u8
..def ........arr8 true  false true  true  false false false false \'\r'u8
..def ........arr8 false true  false true  false false false false \'\n'u8
..def ........arr8 false false false false true  true  false false \'0'u8
..def ........arr8 true  false false false true  true  false false \'1'u8
..def ........arr8 true  false false false false true  true  false \'a'u8
..def ........arr8 true  false false false false false true  false \'A'u8
..def ........arr8 true  true  true  true  true  true  false false \'?'u8
..def ........arr8 false false false false false true  false false \'\s'u8
..def \c \rhs \lhs
  ...arr8.foldl
    \acc \cur .cur \rhs \lhs .acc \c \arr8
      ..pair
        ..or ..and c ..xor rhs lhs ..and rhs lhs
        .arr8 ..xor c ..xor rhs lhs
    ..pair c arr8
    # ..srq.sequence arr8:appl ..pair rhs lhs # works too
    ....lifta2 arr8:appl pair rhs lhs
\u8.addc
..def \b \rhs \lhs
  ...arr8.foldl
    \acc \cur .cur \rhs \lhs .acc \b \arr8
      ..pair
        ..or ..and b ..xor rhs .not lhs ..and rhs .not lhs
        .arr8 ..xor b ..xor rhs lhs
    ..pair b arr8
    # ..srq.sequence arr8:appl ..pair rhs lhs # works too
    ....lifta2 arr8:appl pair rhs lhs
\u8.subb
..def \c \arg
  ...arr8.foldl
    \acc \cur .acc \c \arr8
      ..pair
        ..and c cur
        .arr8 ..xor c cur
    ..pair c arr8
    arg
\u8.incc
..def \b \arg
  ...arr8.foldl
    \acc \cur .acc \b \arr8
      ..pair
        ..and b .not cur
        .arr8 ..xor b cur
    ..pair b arr8
    arg
\u8.decb
..def ..blackbird snd .u8.addc false \u8.add
..def ..blackbird snd .u8.subb false \u8.sub
..def ..bluebird snd .u8.incc true \u8.inc
..def ..bluebird snd .u8.decb true \u8.dec
..def .sgrp u8.add \u8.add:sgrp
..def ..mnid u8.add:sgrp '\0'u8 \u8.add:mnid
..def .arr8:eq bool:eq \u8:eq
..def .arr8:ord bool:ord \u8:ord
..def .arr8:bndd bool:bndd \u8:bndd

# an `IO a` is a function that takes a continuation and returns "$" functions
# wrapping the application of the continuation to a value of type `a`.
#
# no need for `Monoid a => Monoid (IO a)`, it'd be isomorphic to
# `(Applicative f, Monoid a) => Monoid (Ap f a)` for `f ~ IO`
..def .ftor
  \func \ioarg
    \cont .ioarg \arg .cont .func arg
\io:ftor
..def ...appl
  io:ftor
  \arg
    \cont .cont arg
  \iofunc \ioarg
    \cont .iofunc \func ....fmap io:ftor func ioarg cont
\io:appl
..def ..monad
  io:appl
  \ioarg \func
    \cont .ioarg \arg ..func arg cont
\io:monad
# "$" functions like `$put` expect a continuation that takes no arguments, so
# we make wrappers of type `IO ()` that expect continuations that take a `unit`.
# similarly, functions like `$exit` expect no continuation, so we make wrappers
# of type `IO Void` that throw away the continuation.
..def \cont $exit \exit
..def \cont $err \err
..def $get \get
..def \bit \cont ..$put bit .cont unit \put
..def \term \cont ..$dump term .cont unit \dump
# we define a function `main` that takes an `IO ()` and invokes it with the
# continuation `\unit $exit`, throwing away the `unit` and returninng `$exit`
# to ultimately terminate the program
..def \iounit .iounit \unit $exit \main
..def ..bluebird
  .arr8.sequence io:appl
  ..fmap arr8:ftor put
\putc
..def ..bluebird
  .list.sequence io:appl
  ..fmap list:ftor putc
\puts
..def ...fmap io:ftor
  .arr8.sequence opt:appl
  ..arr8.sequence io:appl
    ..pure arr8:appl get
\getc
..def .fix \gets
  ...bind io:monad getc \optchr ..optchr
    \chr ...fmap io:ftor .cons chr gets
    ..pure io:appl nil
\gets
..def .fix \getln
  ...bind io:monad getc \optchr ..optchr
    \chr ...fmap io:ftor
      .cons chr
      .....equal u8:eq '\n'u8 chr
        ..pure io:appl nil
        getln
    ..pure io:appl nil
\getln

# type Parser a = String -> Maybe (a, String)
..def .ftor
  \func \parserarg
    \inp ...fmap opt:ftor
      ..fmap swap:ftor func
      .parserarg inp
\parser:ftor
..def ...appl
  parser:ftor
  \arg
    \inp ..pure opt:appl ..pair arg inp
  \parserfunc \parserarg
    \inp ...bind opt:monad
      .parserfunc inp
      \pairfunc .pairfunc \func
        ...fmap parser:ftor func parserarg
\parser:appl
..def ..monad
  parser:appl
  \parserarg \func
    \inp ...bind opt:monad
      .parserarg inp
      \pairarg .pairarg func
\parser:monad
..def ...altn
  parser:appl
  \inp .pure opt:altn
  \parserrhs \parserlhs
    \inp ...alt opt:altn .parserrhs inp .parserlhs inp
\parser:altn
..def \pred \inp ..inp
  \head \tail ...pred head
    .some ..pair head tail
    none
  none
\satp
..def \inp ..inp
  \head \tail none
  .some ..pair unit nil
\eofp
..def \chr
  .satp ..equal u8:eq chr
\chrp
..def \str
  ..list.sequence parser:appl
  ...fmap list:ftor chrp str
\strp
..def
  .satp .kestrel true
\getp

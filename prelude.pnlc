# vim:ft=pnlc:

.\x x \id
.\x \y x \kestrel
.\x \y y \kite
.\x \f .x f \thrush
.\x \y \f .y .x f \vireo
.\f \x \y .x .y f \cardinal
.\f \g \x ..x g f \bluebird
.\f \g \x \y ..y .x g f \blackbird
.\f \x \g \y ..y g .x f \dove
.\f .\x ..x x f \x ..x x f \fix

.\x x \unit
.$err \void


.\true \false true \true
.\true \false false \false
.\bool .true .false bool \not
.\rhs \lhs .rhs .lhs rhs \and
.\rhs \lhs .lhs .rhs rhs \or
.\rhs \lhs .lhs .id .not rhs \xor

.\opt \some \none .opt some \some
.\some \none none \none
.\opt .false ..true kestrel opt \issome
.\opt .true ..false kestrel opt \isnone
.\opt .$err .id opt \unwrap

.\fst \snd \pair .snd .fst pair \pair
.\pair .\fst \snd fst pair \fst
.\pair .\fst \snd snd pair \snd

.\head \tail \cons \nil .tail .head cons \cons
.\cons \nil nil \nil
.\list .false .\head \tail true list \iscons
.\list .true .\head \tail false list \isnil
.\list .none .\head \tail .head some list \head
.\list .none .\head \tail .tail some list \tail

.\0 \1 \2 \3 \4 \5 \6 \7 \arr8 .7 .6 .5 .4 .3 .2 .1 .0 arr8 \arr8
.\arr8 .\0 \1 \2 \3 \4 \5 \6 \7 0 arr8 \arr8.0
.\arr8 .\0 \1 \2 \3 \4 \5 \6 \7 1 arr8 \arr8.1
.\arr8 .\0 \1 \2 \3 \4 \5 \6 \7 2 arr8 \arr8.2
.\arr8 .\0 \1 \2 \3 \4 \5 \6 \7 3 arr8 \arr8.3
.\arr8 .\0 \1 \2 \3 \4 \5 \6 \7 4 arr8 \arr8.4
.\arr8 .\0 \1 \2 \3 \4 \5 \6 \7 5 arr8 \arr8.5
.\arr8 .\0 \1 \2 \3 \4 \5 \6 \7 6 arr8 \arr8.6
.\arr8 .\0 \1 \2 \3 \4 \5 \6 \7 7 arr8 \arr8.7


.\lt \et \gt lt \lt
.\lt \et \gt et \et
.\lt \et \gt gt \gt
.\cmp .false .false .true cmp \islt
.\cmp .false .true .false cmp \iseq
.\cmp .true .false .false cmp \isgt

.\equal \eq .equal eq \eq
.\eq .\equal equal eq \equal
.\eq .\equal .equal .not blackbird eq \unequal

.\eq \compare \ord .compare .eq ord \ord
.\ord .\eq \compare eq ord \ord:eq
.\ord .\eq \compare compare ord \compare
.\ord \rhs \lhs
  ..false .true .false .lhs .rhs .ord compare
  eq
\ord.eq
.\ord \rhs \lhs .lhs .lhs .rhs .lhs .rhs .ord compare \min
.\ord \rhs \lhs .rhs .lhs .lhs .lhs .rhs .ord compare \max

.\fmap \ftor .fmap ftor \ftor
.\ftor .\fmap fmap ftor \fmap
.\ftor .kestrel ..ftor fmap bluebird \fmapk

.\ftor \pure \apply \appl .apply .pure .ftor appl \appl
.\appl .\ftor \pure \apply ftor appl \appl:ftor
.\appl .\ftor \pure \apply pure appl \pure
.\appl .\ftor \pure \apply apply appl \apply
.\appl \func \fst \snd
  .snd
  ..fst .func ..appl appl:ftor fmap
  .appl apply
\lifta2
.\appl .thrush .appl lifta2 \rapply
# XXX why are these two so slow?
.\appl .kestrel .appl lifta2 \bindl
.\appl .kite .appl lifta2 \bindr
.\appl \left \right \inner
  ..right
  .inner
  .appl bindl
  .left
  .appl bindr
\between

.\appl \bind \monad .bind .appl monad \monad
.\monad .\appl \bind appl monad \monad:appl
.\monad .\appl \bind bind monad \bind
.\monad \x \f ..f kestrel .x .monad bind \bindk
.\monad \f \g \x .g ..x f .monad bind \kleisli

.\appl \empty \alt \altn .alt .empty .appl altn \altn
.\altn .\appl \empty \alt appl altn \altn:appl
.\altn .\appl \empty \alt empty altn \empty
.\altn .\appl \empty \alt alt altn \alt
.\many1 \altn \val
  ..nil ..altn altn:appl pure ..val .altn many1 .altn alt
\many
.\many \altn \val
  ..val .altn many .val .cons ..altn altn:appl lifta2
\many1
  ...many .many1 bluebird fix ...many1 .many bluebird fix
\many \many1
.\altn \sep \elem
  ...elem .sep ..altn altn:appl bindr .altn many
  .elem
  .cons ..altn altn:appl lifta2
\sepby1
.\altn \sep \elem
  ..nil ..altn altn:appl pure
  ..elem .sep .altn sepby1
  .altn alt
\sepby


  ..\rhs \lhs .lhs .not .id rhs
  eq
\bool:eq
  ..\rhs \lhs ..et .gt lhs ..lt .et lhs rhs
  .bool:eq
  ord
\bool:ord

# TODO instance ord
  ..\func \optarg
    .none .\arg ..arg func some optarg
  ftor
\opt:ftor
  ..\optfunc \optarg
    .none .\func .optarg .func .opt:ftor fmap optfunc
  .some
  .opt:ftor
  appl
\opt:appl
  ..\optarg \func .none .func optarg
  .opt:appl
  monad
\opt:monad
  ..\optrhs \optlhs .optrhs .some optlhs
  .none
  .opt:appl
  altn
\opt:altn

# TODO instance ord
# TODO induction
.some \succ
.none \zero
.isnone \iszero
.unwrap \pred
# XXX redefine in terms of induction
..\add \rhs \lhs .lhs ...lhs succ add rhs fix \add
..\mul \rhs \lhs .zero ...lhs mul ..lhs add bluebird rhs fix \mul
.opt:ftor \nat:ftor
.opt:appl \nat:appl
.opt:altn \nat:altn
.opt:monad \nat:monad

# TODO instance ord
  ..\func \pairarg
    .\fstarg \sndarg
      ..sndarg func ..fstarg func pair
    pairarg
  ftor
\pair:ftor
  ..\pairfunc \pairarg
    .\fstfunc \sndfunc .\fstarg \sndarg
      ..sndarg sndfunc ..fstarg fstfunc pair
    pairarg pairfunc
  .\arg .arg .arg pair
  .pair:ftor
  appl
\pair:appl
  ..\pairarg \func
    .\fstarg \sndarg
      ...sndarg func snd ...fstarg func fst pair
    pairarg
  .pair:appl
  monad
\pair:monad
.\func \zero \pair
  .\fst \snd .snd ..fst .zero func func pair
\pair.foldl # XXX foldable
.\func \zero \pair
  .\fst \snd ..zero .snd func .fst func pair
\pair.foldr # XXX foldable
.\elem:appl
  ..pair .elem:appl pure
  ..appl apply
  pair.foldl
\pair.sequence

# TODO instance ord
..\list.foldl \func \zero \list
  .zero
  .\head \tail
    .tail
    ..head .zero func
    .func
    list.foldl
  list
fix \list.foldl # XXX foldable
..\list.foldr \func \zero \list
  .zero
  .\head \tail
    ..tail .zero .func list.foldr
    .head
    func
  list
fix \list.foldr # XXX foldable
..zero ..succ kestrel list.foldr \length
..nil ..cons cardinal list.foldl \list.reverse
..none .\elem \acc ..elem .id acc some list.foldr \last
..none .\elem \acc ..nil ..elem cons acc some list.foldr \init
.\elem:appl
  ..nil .elem:appl pure
  ..cons .elem:appl lifta2
  list.foldr
\list.sequence # XXX support anything `traversable`
  ..\func
    .nil
    ..func .cons bluebird
    list.foldr
  ftor
\list:ftor
  ..\listfunc \listarg
    .listfunc
    .nil
    .\func \acc
      .listarg .acc ..func .cons bluebird list.foldr
    list.foldr
  .\arg .nil .arg cons
  .list:ftor
  appl
\list:appl
  ..\listarg \func
    .listarg
    .nil
    .\arg \acc
      ..arg func .acc .cons list.foldr
    list.foldr
  .list:appl
  monad
\list:monad
  ...cons list.foldr
  .nil
  .list:appl
  altn
\list:altn

  ..\func \arg8
    .\a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ..a7 func
      ..a6 func
      ..a5 func
      ..a4 func
      ..a3 func
      ..a2 func
      ..a1 func
      ..a0 func
      arr8
    arg8
  ftor
\arr8:ftor
  ..\func8 \arg8
    .\f0 \f1 \f2 \f3 \f4 \f5 \f6 \f7
      .\a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
        ..a7 f7
        ..a6 f6
        ..a5 f5
        ..a4 f4
        ..a3 f3
        ..a2 f2
        ..a1 f1
        ..a0 f0
        arr8
      arg8
    func8
  .\arg
    .arg .arg .arg .arg .arg .arg .arg .arg arr8
  .arr8:ftor
  appl
\arr8:appl
  ..\arg8 \func
    .\a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ...a7 func arr8.7
      ...a6 func arr8.6
      ...a5 func arr8.5
      ...a4 func arr8.4
      ...a3 func arr8.3
      ...a2 func arr8.2
      ...a1 func arr8.1
      ...a0 func arr8.0
      arr8
    arg8
  .arr8:appl
  monad
\arr8:monad
.\func \zero \arr8
  .\a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    ..a7 ..a6 ..a5 ..a4 ..a3 ..a2 ..a1 ..a0 .zero
    func func func func func func func func id
  arr8
\arr8.foldl # XXX foldable
.\func \zero \arr8
  .\a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    ........zero
    .a7 func
    .a6 func
    .a5 func
    .a4 func
    .a3 func
    .a2 func
    .a1 func
    .a0 func
  arr8
\arr8.foldr # XXX foldable
..arr8 .thrush arr8.foldr \arr8.reverse
.\elem:appl
  ..arr8 .elem:appl pure
  ..elem:appl apply
  arr8.foldl
\arr8.sequence # XXX support anything `traversable`
.\elem:eq
  ....elem:eq equal .arr8:appl lifta2
  ..true .and arr8.foldr
  blackbird
  eq
\arr8:eq # XXX support anything `foldable`
.\elem:ord
  ....elem:ord compare .arr8:appl lifta2
  ..et .\cur \acc .acc .cur .acc acc arr8.foldr
  blackbird
  .arr8:eq
  ord
\arr8:ord # XXX support anything `foldable`

# type U8 = (Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool)
..false .false .false .false .false .false .false .false arr8 \'\0'u8
..false .true  .true  .true  .true  .true  .false .false arr8 \'|'u8
..false .false .true  .true  .true  .true  .true  .false arr8 \'>'u8
..false .false .true  .true  .true  .true  .false .false arr8 \'<'u8
..false .false .true  .false .true  .false .true  .true  arr8 \'+'u8
..false .false .true  .false .true  .true  .false .true  arr8 \'-'u8
..false .false .true  .false .true  .true  .true  .false arr8 \'.'u8
..false .false .true  .false .true  .true  .false .false arr8 \','u8
..false .true  .false .true  .true  .false .true  .true  arr8 \'['u8
..false .true  .false .true  .true  .true  .false .true  arr8 \']'u8
..false .false .true  .false .false .false .false .true  arr8 \'!'u8
..false .false .true  .true  .true  .true  .true  .false arr8 \'>'u8
..false .false .false .false .true  .true  .false .true  arr8 \'\r'u8
..false .false .false .false .true  .false .true  .false arr8 \'\n'u8
..false .false .true  .true  .false .false .false .false arr8 \'0'u8
..false .false .true  .true  .false .false .false .true  arr8 \'1'u8
..false .true  .true  .false .false .false .false .true  arr8 \'a'u8
..false .true  .false .false .false .false .false .true  arr8 \'A'u8
..false .false .true  .true  .true  .true  .true  .true  arr8 \'?'u8
..false .false .true  .false .false .false .false .false arr8 \'\s'u8
.\c \rhs \lhs
  # ...lhs .rhs pair .arr8:appl pair.sequence # works too
  ..lhs .rhs .pair .arr8:appl lifta2
  ..arr8 .c pair
  .\acc \cur
    .\rhs \lhs
      .\c \arr8
        ....lhs .rhs xor .c xor arr8
        ...lhs .rhs and ...lhs .rhs xor .c and or
        pair
      acc
    cur
  arr8.foldl
\u8.addc
.\b \rhs \lhs
  # ...lhs .rhs pair .arr8:appl pair.sequence # works too
  ..lhs .rhs .pair .arr8:appl lifta2
  ..arr8 .b pair
  .\acc \cur
    .\rhs \lhs
      .\b \arr8
        ....lhs .rhs xor .b xor arr8
        ....lhs not .rhs and ....lhs not .rhs xor .b and or
        pair
      acc
    cur
  arr8.foldl
\u8.subb
.\c \arg
  .arg
  ..arr8 .c pair
  .\acc \cur
    .\c \arr8
      ...cur .c xor arr8
      ..cur .c and
      pair
    acc
  arr8.foldl
\u8.incc
.\b \arg
  .arg
  ..arr8 .b pair
  .\acc \cur
    .\b \arr8
      ...cur .b xor arr8
      ...cur not .b and
      pair
    acc
  arr8.foldl
\u8.decb
...false u8.addc .snd blackbird \u8.add
...false u8.subb .snd blackbird \u8.sub
...true u8.incc .snd bluebird \u8.inc
...true u8.decb .snd bluebird \u8.dec
..bool:eq arr8:eq \u8:eq
..bool:ord arr8:ord \u8:ord

# an `IO a` is a function that takes a continuation and returns "$" functions
# wrapping the application of the continuation to a value of type `a`
  ..\func \ioarg
    \cont .\arg ..arg func cont ioarg
  ftor
\io:ftor
  ..\iofunc \ioarg
    \cont .\func .cont .ioarg .func .io:ftor fmap iofunc
  .\arg
    \cont .arg cont
  .io:ftor
  appl
\io:appl
  ..\ioarg \func
    \cont .\arg .cont .arg func ioarg
  .io:appl
  monad
\io:monad
# "$" functions like `$put` expect a continuation that takes no arguments, so
# we make wrappers of type `IO ()` that expect continuations that take a `unit`.
# similarly, the top-level term gets called with a continuation that expects no
# arguments, so we define a function `main` that takes an `IO ()` and throws
# away the `unit` instead of giving it to the continuation.
.\iounit \cont .\unit cont iounit \main
.\bit \cont ..unit cont .bit $put \put
.\term \cont ..unit cont .term $dbg \dbg
.$get \get
  ...put .arr8:ftor fmap
  ..io:appl arr8.sequence
  bluebird
\putc
  ...putc .list:ftor fmap
  ..io:appl list.sequence
  bluebird
\puts
    ....get .arr8:appl pure
    .io:appl arr8.sequence
  ..opt:appl arr8.sequence
  .io:ftor fmap
\getc
..\gets
  .\optchr
    ..nil .io:appl pure
    .\chr .gets ..chr cons .io:ftor fmap
    optchr
  .getc
  .io:monad bind
fix \gets
..\getln
  .\optchr
    ..nil .io:appl pure
    .\chr
      ..getln
      ..nil .io:appl pure
      .chr .'\n'u8 .u8:eq equal
      ..chr cons
      .io:ftor fmap
    optchr
  .getc
  .io:monad bind
fix \getln

# type Parser a = String -> Maybe (a, String)
  ..\func \parserarg
    \inp
      ..inp parserarg
      .\pairarg ..func .pair bluebird pairarg
      .opt:ftor fmap
  ftor
\parser:ftor
  ..\parserfunc \parserarg
    \inp
      .\pairfunc .\func .parserarg .func .parser:ftor fmap pairfunc
      ..inp parserfunc
      .opt:monad bind
  .\arg
    \inp ..inp .arg pair some
  .parser:ftor
  appl
\parser:appl
  ..\parserarg \func
    \inp
      .\pairarg .func pairarg
      ..inp parserarg
      .opt:monad bind
  .parser:appl
  monad
\parser:monad
  ..\parserrhs \parserlhs
    \inp ..inp parserlhs ..inp parserrhs .opt:altn alt
  .\inp none
  .parser:appl
  altn
\parser:altn
.\pred \inp
  .none
  .\head \tail
    .none
    ...tail .head pair some
    .head pred
  inp
\satp
.\inp
  ...nil .unit pair some
  .\head \tail none
  inp
\eofp
.\chr
  ..chr .u8:eq equal satp
\chrp
.\str
  ..str .chrp .list:ftor fmap
  .parser:appl list.sequence
\strp

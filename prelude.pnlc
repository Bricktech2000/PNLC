# vim:tw=80:ft=pnlc:
.\p .p \x \f .f x \def

# this file is organized into a few sections separated by form feeds. sum and
# product types are encoded using the Scott encoding. for operators we generally
# take `\rhs \lhs` so partial appication is useful. typeclasses are product type
# constructors and typeclass instances are product types. we keep their names
# short, at most four characters, because resolution is done manually; when you
# see a colon in an identifier, think typeclass instance.

..def \x x \id
..def \x \y x \kestrel
..def \x \y y \kite
..def \x \f .f x \thrush
..def \x \y \f ..f x y \vireo
..def \x \y \z \f ...f x y z \veery # made this one up
..def \x \y \f ..f y x \finch
..def \x \f \y ..f y x \robin
..def \f .f f \mockingbird
..def \f \x ..f x x \warbler
..def \f \x \y ..f y x \cardinal
..def \f \x \y \z ...f x z y \cardinalstar
..def \g \f \x .f .g x \queerbird
..def \f \x \g .f .g x \quixoticbird
..def \x \f \g .f .g x \quizzicalbird
..def \g \x \f .f .g x \quirkybird
..def \x \g \f .f .g x \quackybird
..def \f \g \x .f .g x \bluebird
..def \f \g \x \y .f ..g x y \blackbird
..def \f \g \x \y \z .f ...g x y z \bunting
..def \f \g \h \x .f .g .h x \becard
..def \f \x \g \y ..f x .g y \dove
..def \f \x \y \g \z ...f x y .g z \dickcissel
..def \f \g \x \h \y ..f .g x .h y \dovekies
..def \f \x \g \y \z ..f x ..g y z \eagle
..def \f \g \x ..f x .g x \starling
..def \f \g \x ..f .g x x \violet # -backed starling
..def \f \g \x \y ..f y .g x \goldfinch
..def \f \g \h \x ..f .g x .h x \phi
..def \f \g \x \y ..f .g x .g y \psi
..def \f .\x .f .x x \x .f .x x \fix

 # constructors and eliminators

..def $err \void
..def \x x \unit

# def:bool
..def \true \false true \true
..def \true \false false \false
..def ..vireo false true \not
..def \rhs \lhs ..rhs lhs rhs \and
..def \rhs \lhs ..rhs rhs lhs \or
..def \rhs \lhs ...rhs not id lhs \xor

# def:cmp
..def \lt \et \gt lt \lt
..def \lt \et \gt et \et
..def \lt \et \gt gt \gt
..def ...veery true false false \islt
..def ...veery false true false \iset
..def ...veery false false true \isgt
..def ...veery false true true \isge
..def ...veery true false true \isne
..def ...veery true true false \isle

# def:opt
..def \opt \some \none .some opt \some
..def \some \none none \none
..def ..vireo .kestrel true false \issome
..def ..vireo .kestrel false true \isnone
..def ..vireo id $err \unwrap

# def:nat
..def \pred \succ \zero .succ pred \succ
..def \succ \zero zero \zero
..def ..vireo .kestrel true false \issucc
..def ..vireo .kestrel false true \iszero
..def ..vireo some none \pred

..def \fst \snd ..vireo fst snd \pair
..def .thrush \fst \snd fst \fst
..def .thrush \fst \snd snd \snd

# def:res
..def \val \ok \err .ok val \ok
..def \val \ok \err .err val \err
..def ..vireo .kestrel true .kestrel false \isok
..def ..vireo .kestrel false .kestrel true \iserr
..def ..vireo some .kestrel none \getok
..def ..vireo .kestrel none some \geterr

# def:list
..def \head \tail \cons \nil ..cons head tail \cons
..def \cons \nil nil \nil
..def ..vireo .kestrel .kestrel true false \iscons
..def ..vireo .kestrel .kestrel false true \isnil
..def ..vireo \head \tail .some head none \head
..def ..vireo \head \tail .some tail none \tail

# def:free the free monad
# data Free f a = Roll (f (Free f a)) | Return a
..def \term \roll \return .roll term \roll
..def \var \roll \return .return var \return
..def ..vireo .kestrel true .kestrel false \isroll
..def ..vireo .kestrel false .kestrel true \isreturn
..def ..vireo some .kestrel none \term
..def ..vireo .kestrel none some \var

# the cofree comonad
# data Cofree f a = Cofree (f (Cofree a)) a
..def \trace \ann ..vireo trace ann \cofree
..def .thrush \trace \ann trace \trace
..def .thrush \trace \ann ann \ann

# type Arr8 a = (a, a, a, a, a, a, a, a)
..def \0 \1 \2 \3 \4 \5 \6 \7 \arr8 ........arr8 0 1 2 3 4 5 6 7 \arr8
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 0 \arr8.0
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 1 \arr8.1
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 2 \arr8.2
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 3 \arr8.3
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 4 \arr8.4
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 5 \arr8.5
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 6 \arr8.6
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 7 \arr8.7

# def:u8
# type U8 = Arr8 Bool = (Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool)
..def ........arr8 false false false false false false false false \nul
..def ........arr8 true  false false false false false false false \soh
..def ........arr8 false true  false false false false false false \stx
..def ........arr8 true  true  false false false false false false \etx
..def ........arr8 false false true  false false false false false \eot
..def ........arr8 true  false true  false false false false false \enq
..def ........arr8 false true  true  false false false false false \ack
..def ........arr8 true  true  true  false false false false false \bel
..def ........arr8 false false false true  false false false false \bs
..def ........arr8 true  false false true  false false false false \ht
..def ........arr8 false true  false true  false false false false \lf
..def ........arr8 true  true  false true  false false false false \vt
..def ........arr8 false false true  true  false false false false \ff
..def ........arr8 true  false true  true  false false false false \cr
..def ........arr8 false true  true  true  false false false false \so
..def ........arr8 true  true  true  true  false false false false \si
..def ........arr8 false false false false true  false false false \dle
..def ........arr8 true  false false false true  false false false \dc1
..def ........arr8 false true  false false true  false false false \dc2
..def ........arr8 true  true  false false true  false false false \dc3
..def ........arr8 false false true  false true  false false false \dc4
..def ........arr8 true  false true  false true  false false false \nak
..def ........arr8 false true  true  false true  false false false \syn
..def ........arr8 true  true  true  false true  false false false \etb
..def ........arr8 false false false true  true  false false false \can
..def ........arr8 true  false false true  true  false false false \em
..def ........arr8 false true  false true  true  false false false \sub
..def ........arr8 true  true  false true  true  false false false \esc
..def ........arr8 false false true  true  true  false false false \fs
..def ........arr8 true  false true  true  true  false false false \gs
..def ........arr8 false true  true  true  true  false false false \rs
..def ........arr8 true  true  true  true  true  false false false \us
..def ........arr8 false false false false false true  false false \sp
..def ........arr8 true  false false false false true  false false \'!'
..def ........arr8 false true  false false false true  false false \'"'
..def ........arr8 true  true  false false false true  false false \'#'
..def ........arr8 false false true  false false true  false false \'$'
..def ........arr8 true  false true  false false true  false false \'%'
..def ........arr8 false true  true  false false true  false false \'&'
..def ........arr8 true  true  true  false false true  false false \'''
..def ........arr8 false false false true  false true  false false \'('
..def ........arr8 true  false false true  false true  false false \')'
..def ........arr8 false true  false true  false true  false false \'*'
..def ........arr8 true  true  false true  false true  false false \'+'
..def ........arr8 false false true  true  false true  false false \','
..def ........arr8 true  false true  true  false true  false false \'-'
..def ........arr8 false true  true  true  false true  false false \'.'
..def ........arr8 true  true  true  true  false true  false false \'/'
..def ........arr8 false false false false true  true  false false \'0'
..def ........arr8 true  false false false true  true  false false \'1'
..def ........arr8 false true  false false true  true  false false \'2'
..def ........arr8 true  true  false false true  true  false false \'3'
..def ........arr8 false false true  false true  true  false false \'4'
..def ........arr8 true  false true  false true  true  false false \'5'
..def ........arr8 false true  true  false true  true  false false \'6'
..def ........arr8 true  true  true  false true  true  false false \'7'
..def ........arr8 false false false true  true  true  false false \'8'
..def ........arr8 true  false false true  true  true  false false \'9'
..def ........arr8 false true  false true  true  true  false false \':'
..def ........arr8 true  true  false true  true  true  false false \';'
..def ........arr8 false false true  true  true  true  false false \'<'
..def ........arr8 true  false true  true  true  true  false false \'='
..def ........arr8 false true  true  true  true  true  false false \'>'
..def ........arr8 true  true  true  true  true  true  false false \'?'
..def ........arr8 false false false false false false true  false \'@'
..def ........arr8 true  false false false false false true  false \'A'
..def ........arr8 false true  false false false false true  false \'B'
..def ........arr8 true  true  false false false false true  false \'C'
..def ........arr8 false false true  false false false true  false \'D'
..def ........arr8 true  false true  false false false true  false \'E'
..def ........arr8 false true  true  false false false true  false \'F'
..def ........arr8 true  true  true  false false false true  false \'G'
..def ........arr8 false false false true  false false true  false \'H'
..def ........arr8 true  false false true  false false true  false \'I'
..def ........arr8 false true  false true  false false true  false \'J'
..def ........arr8 true  true  false true  false false true  false \'K'
..def ........arr8 false false true  true  false false true  false \'L'
..def ........arr8 true  false true  true  false false true  false \'M'
..def ........arr8 false true  true  true  false false true  false \'N'
..def ........arr8 true  true  true  true  false false true  false \'O'
..def ........arr8 false false false false true  false true  false \'P'
..def ........arr8 true  false false false true  false true  false \'Q'
..def ........arr8 false true  false false true  false true  false \'R'
..def ........arr8 true  true  false false true  false true  false \'S'
..def ........arr8 false false true  false true  false true  false \'T'
..def ........arr8 true  false true  false true  false true  false \'U'
..def ........arr8 false true  true  false true  false true  false \'V'
..def ........arr8 true  true  true  false true  false true  false \'W'
..def ........arr8 false false false true  true  false true  false \'X'
..def ........arr8 true  false false true  true  false true  false \'Y'
..def ........arr8 false true  false true  true  false true  false \'Z'
..def ........arr8 true  true  false true  true  false true  false \'['
..def ........arr8 false false true  true  true  false true  false \'\'
..def ........arr8 true  false true  true  true  false true  false \']'
..def ........arr8 false true  true  true  true  false true  false \'^'
..def ........arr8 true  true  true  true  true  false true  false \'_'
..def ........arr8 false false false false false true  true  false \'`'
..def ........arr8 true  false false false false true  true  false \'a'
..def ........arr8 false true  false false false true  true  false \'b'
..def ........arr8 true  true  false false false true  true  false \'c'
..def ........arr8 false false true  false false true  true  false \'d'
..def ........arr8 true  false true  false false true  true  false \'e'
..def ........arr8 false true  true  false false true  true  false \'f'
..def ........arr8 true  true  true  false false true  true  false \'g'
..def ........arr8 false false false true  false true  true  false \'h'
..def ........arr8 true  false false true  false true  true  false \'i'
..def ........arr8 false true  false true  false true  true  false \'j'
..def ........arr8 true  true  false true  false true  true  false \'k'
..def ........arr8 false false true  true  false true  true  false \'l'
..def ........arr8 true  false true  true  false true  true  false \'m'
..def ........arr8 false true  true  true  false true  true  false \'n'
..def ........arr8 true  true  true  true  false true  true  false \'o'
..def ........arr8 false false false false true  true  true  false \'p'
..def ........arr8 true  false false false true  true  true  false \'q'
..def ........arr8 false true  false false true  true  true  false \'r'
..def ........arr8 true  true  false false true  true  true  false \'s'
..def ........arr8 false false true  false true  true  true  false \'t'
..def ........arr8 true  false true  false true  true  true  false \'u'
..def ........arr8 false true  true  false true  true  true  false \'v'
..def ........arr8 true  true  true  false true  true  true  false \'w'
..def ........arr8 false false false true  true  true  true  false \'x'
..def ........arr8 true  false false true  true  true  true  false \'y'
..def ........arr8 false true  false true  true  true  true  false \'z'
..def ........arr8 true  true  false true  true  true  true  false \'{'
..def ........arr8 false false true  true  true  true  true  false \'|'
..def ........arr8 true  false true  true  true  true  true  false \'}'
..def ........arr8 false true  true  true  true  true  true  false \'~'
..def ........arr8 true  true  true  true  true  true  true  false \del
..def nul \'\0'
..def bel \'\a'
..def bs  \'\b'
..def ht  \'\t'
..def lf  \'\n'
..def vt  \'\v'
..def ff  \'\f'
..def cr  \'\r'
..def esc \'\e'
..def \' sp  \' # eg .putc .' '
..def .cons nul \:nul
..def .cons soh \:soh
..def .cons stx \:stx
..def .cons etx \:etx
..def .cons eot \:eot
..def .cons enq \:enq
..def .cons ack \:ack
..def .cons bel \:bel
..def .cons bs  \:bs
..def .cons ht  \:ht
..def .cons lf  \:lf
..def .cons vt  \:vt
..def .cons ff  \:ff
..def .cons cr  \:cr
..def .cons so  \:so
..def .cons si  \:si
..def .cons dle \:dle
..def .cons dc1 \:dc1
..def .cons dc2 \:dc2
..def .cons dc3 \:dc3
..def .cons dc4 \:dc4
..def .cons nak \:nak
..def .cons syn \:syn
..def .cons etb \:etb
..def .cons can \:can
..def .cons em  \:em
..def .cons sub \:sub
..def .cons esc \:esc
..def .cons fs  \:fs
..def .cons gs  \:gs
..def .cons rs  \:rs
..def .cons us  \:us
..def .cons sp  \:sp
..def .cons '!' \:!
..def .cons '"' \:"
..def .cons '#' \:#
..def .cons '$' \:$
..def .cons '%' \:%
..def .cons '&' \:&
..def .cons ''' \:'
..def .cons '(' \:(
..def .cons ')' \:)
..def .cons '*' \:*
..def .cons '+' \:+
..def .cons ',' \:,
..def .cons '-' \:-
..def .cons '.' \:.
..def .cons '/' \:/
..def .cons '0' \:0
..def .cons '1' \:1
..def .cons '2' \:2
..def .cons '3' \:3
..def .cons '4' \:4
..def .cons '5' \:5
..def .cons '6' \:6
..def .cons '7' \:7
..def .cons '8' \:8
..def .cons '9' \:9
..def .cons ':' \::
..def .cons ';' \:;
..def .cons '<' \:<
..def .cons '=' \:=
..def .cons '>' \:>
..def .cons '?' \:?
..def .cons '@' \:@
..def .cons 'A' \:A
..def .cons 'B' \:B
..def .cons 'C' \:C
..def .cons 'D' \:D
..def .cons 'E' \:E
..def .cons 'F' \:F
..def .cons 'G' \:G
..def .cons 'H' \:H
..def .cons 'I' \:I
..def .cons 'J' \:J
..def .cons 'K' \:K
..def .cons 'L' \:L
..def .cons 'M' \:M
..def .cons 'N' \:N
..def .cons 'O' \:O
..def .cons 'P' \:P
..def .cons 'Q' \:Q
..def .cons 'R' \:R
..def .cons 'S' \:S
..def .cons 'T' \:T
..def .cons 'U' \:U
..def .cons 'V' \:V
..def .cons 'W' \:W
..def .cons 'X' \:X
..def .cons 'Y' \:Y
..def .cons 'Z' \:Z
..def .cons '[' \:[
..def .cons '\' \:\
..def .cons ']' \:]
..def .cons '^' \:^
..def .cons '_' \:_
..def .cons '`' \:`
..def .cons 'a' \:a
..def .cons 'b' \:b
..def .cons 'c' \:c
..def .cons 'd' \:d
..def .cons 'e' \:e
..def .cons 'f' \:f
..def .cons 'g' \:g
..def .cons 'h' \:h
..def .cons 'i' \:i
..def .cons 'j' \:j
..def .cons 'k' \:k
..def .cons 'l' \:l
..def .cons 'm' \:m
..def .cons 'n' \:n
..def .cons 'o' \:o
..def .cons 'p' \:p
..def .cons 'q' \:q
..def .cons 'r' \:r
..def .cons 's' \:s
..def .cons 't' \:t
..def .cons 'u' \:u
..def .cons 'v' \:v
..def .cons 'w' \:w
..def .cons 'x' \:x
..def .cons 'y' \:y
..def .cons 'z' \:z
..def .cons '{' \:{
..def .cons '|' \:|
..def .cons '}' \:}
..def .cons '~' \:~
..def .cons del \:del
..def :nul \:\0
..def :bel \:\a
..def :bs  \:\b
..def :ht  \:\t
..def :lf  \:\n
..def :vt  \:\v
..def :ff  \:\f
..def :cr  \:\r
..def :esc \:\e
..def :sp  \: # eg .puts .:  nil

 # typeclass definitions and utility instances

..def \equal .thrush equal \eq
..def .thrush \equal equal \equal
..def .thrush \equal ..blackbird not equal \unequal

..def \eq \compare ..vireo eq compare \ord
..def .thrush \eq \compare eq \ord:eq
..def .thrush \eq \compare compare \compare
..def \ord \rhs \lhs .eq
  ......compare ord rhs lhs false true false
\ord.eq
# return the left-hand side when the arguments compare equal
..def \ord \rhs \lhs ......compare ord rhs lhs lhs lhs rhs \min
..def \ord \rhs \lhs ......compare ord rhs lhs rhs lhs lhs \max
..def \ord .thrush .min ord \min:sgrp
..def \ord .thrush .max ord \max:sgrp
..def \ord \bndd .bndd \top \bot
  ..vireo .min:sgrp ord top
\min:mnid
..def \ord \bndd .bndd \top \bot
  ..vireo .max:sgrp ord bot
\max:mnid
# return the argument when it is equal to one or both bounds
..def \ord \lo \hi ..bluebird ..min ord hi ..max ord lo \clamp
..def \ord \lo \hi \val ..and
  .isge ...compare ord lo val
  .isle ...compare ord hi val
\clamped

..def \top \bot ..vireo top bot \bndd
..def .thrush \top \bot top \top
..def .thrush \top \bot bot \bot

# a minimalistic programmer-facing debug representation. there is no requirement
# for the output to be unambiguous.
# debug :: (Dbg a) => a -> Dlist U8
..def \debug .thrush debug \dbg
..def .thrush \debug debug \debug
# the debugged debugging, prints out a `DList U8` as itself
..def .dbg id \dbgged:dbg
# the character debugging, prints out a `U8` as itself
..def .dbg cons \chr:dbg
# places a debugging within a left and right `Dlist U8`
..def \left \right \inner:dbg .inner:dbg \innerdebug
  .dbg \inner ...becard left .innerdebug inner right
\within:dbg
..def ..within:dbg :( :) \paren:dbg
..def ..within:dbg :[ :] \brack:dbg
..def ..within:dbg :{ :} \brace:dbg
..def ..within:dbg :< :> \angle:dbg
..def ..within:dbg :" :" \quote:dbg
..def ..within:dbg :' :' \acute:dbg
..def ..within:dbg :` :` \grave:dbg

# sequencing of evaluation order. forcing a call to `force` forces the first
# argument then evaluates to the second argument. partially applying `force`
# effectively gives you a "forcing" identity function: a function which returns
# its argument but which also forces some other unrelated computation. `force`
# on a unit type is the identity function. `force` on a void type is void.
# `force` on a sum type forces component types by case analysis. `force` on a
# product type forces component types then composes the results together. for
# example, forcing `nil` is the identity function and forcing a `cons` cell is
# the composition of forcing the head and recursively forcing the tail.
# force :: a -> b -> b
..def \force .thrush force \seq
..def .thrush \force force \force
# the forced sequencing, forces a forcing identity function as itself
..def .seq id \forced:seq
# the lazy sequencing, doesn't actually force the argument. for example, `.force
# .list:seq lazy:seq` forces the shape of a list but doesn't force its elements
..def .seq .kestrel id \lazy:seq

..def \sappend .thrush sappend \sgrp
..def .thrush \sappend sappend \sappend
# dual semigroup, the semigroup obtained by swapping arguments to `sappend`
..def \inner:sgrp .inner:sgrp \sappend .sgrp .cardinal sappend \dual:sgrp
# the left-zero and right-zero semigroups over the carrier set
..def .sgrp kite \first:sgrp
..def .sgrp kestrel \last:sgrp
# can't use `cata` here because the `natf` endofunctor isn't defined yet
..def \sgrp \elem .fix \stimes \count
  ..count ..bluebird ..sappend sgrp elem stimes elem
\stimes

..def \sgrp \mempty ..vireo sgrp mempty \mnid
..def .thrush \sgrp \mempty sgrp \mnid:sgrp
..def .thrush \sgrp \mempty mempty \mempty
# dual monoid, the monoid obtained by swapping arguments to `sappend`
..def \inner:mnid .inner:mnid \sgrp .mnid .dual:sgrp sgrp \dual:mnid
# the monoid of endomorphisms under composition
..def .sgrp bluebird \endo:sgrp
..def ..mnid endo:sgrp id \endo:mnid
..def \mnid \elem \count .mnid \sgrp \mempty
  ..count ..stimes sgrp elem mempty
\mtimes

..def \fmap .thrush fmap \ftor
..def .thrush \fmap fmap \fmap
..def \ftor ..bluebird .fmap ftor kestrel \fmapk
..def \ftor ...phi pair ..fmap ftor fst ..fmap ftor snd \unzip
# the const functor, whose `fmap` is a no-op. it is also the "base" functor for
# `solo`, with the property `Fix (Const a) = Solo a`.
# `data Const a b = Const a deriving Functor`
..def .ftor kestrel \const:ftor

..def \ftor \pure \apply ...veery ftor pure apply \aptv
..def .thrush \ftor \pure \apply ftor \aptv:ftor
..def .thrush \ftor \pure \apply pure \pure
..def .thrush \ftor \pure \apply apply \apply
..def \aptv \func \fst \snd
  ...apply aptv
    ...fmap .aptv:ftor aptv func fst
    snd
\lifta2
..def \aptv ..lifta2 aptv thrush \rapply
..def \aptv ..lifta2 aptv kestrel \seql
..def \aptv ..lifta2 aptv kite \seqr
..def \aptv \left \right \inner
  ...seqr aptv left ...seql aptv inner right
\between
..def \aptv ..vireo id .kestrel ..pure aptv unit \when
..def \aptv ..vireo .kestrel ..pure aptv unit id \unless
# `(Applicative f, Monoid a) => Monoid (Ap f a)` by lifting the monoid pointwise
..def \aptv \inner:sgrp .inner:sgrp \innersappend
  .sgrp ..lifta2 aptv innersappend
\ap:sgrp
..def \aptv \inner:mnid .inner:mnid \inner:sgrp \innermempty
  ..mnid
    ..ap:sgrp aptv inner:sgrp
    ..pure aptv innermempty
\ap:mnid

..def \aptv \bind ..vireo aptv bind \mnad
..def .thrush \aptv \bind aptv \mnad:aptv
..def .thrush \aptv \bind bind \bind
..def \mnad \x \f ...bind mnad x .kestrel f \bindk
..def \mnad ..bind mnad id \join
..def \mnad \f \g \x ...bind mnad .f x g \kleisli
# the monoid of Kleisli endomorphisms under Kleisli composition
..def \mnad .sgrp .kleisli mnad \kendo:sgrp
..def \mnad ..mnid .kendo:sgrp mnad .pure .mnad:aptv mnad \kendo:mnid
# the identity monad
..def .ftor id \ident:ftor
..def ...aptv ident:ftor id id \ident:aptv
..def ..mnad ident:aptv .cardinal id \ident:mnad

..def \aptv \empty \alt ...veery aptv empty alt \altv
..def .thrush \aptv \empty \alt aptv \altv:aptv
..def .thrush \aptv \empty \alt empty \empty
..def .thrush \aptv \empty \alt alt \alt
..def \altv ..vireo ..pure .altv:aptv altv nil .empty altv \guard
..def \many1 \altv \val
  ...alt altv ..pure .altv:aptv altv nil ..many1 altv val
\many
..def \many \altv \val
  ....lifta2 .altv:aptv altv cons val ..many altv val
\many1
..def .fix ..bluebird many1 many
..def .fix ..bluebird many many1
\many \many1
..def \altv \sep \elem
  ....lifta2 .altv:aptv altv cons
    elem
    ..many altv ...seqr .altv:aptv altv sep elem
\sepby1
..def \altv \sep \elem
  ...alt altv
    ..pure .altv:aptv altv nil
    ...sepby1 altv sep elem
\sepby
..def \altv \val
  ...alt altv ..pure .altv:aptv altv none
    ...fmap .aptv:ftor .altv:aptv altv some val
\option
# the monoid induced by `alt`
..def \altv .sgrp .alt altv \alt:sgrp
..def \altv ..mnid .alt:sgrp altv .empty altv \alt:mnid
# no need for `asum`, it'd be equivalent to `.fold .alt:mnid something:altn`

# "The Foldable class represents data structures that can be reduced to a
# summary value one element at a time." well that's the list catamorphism, so
# why not output the list directly and let the user consume it as they please?
# `foldr` and `tolist` are interdefinable and both are lazy, so we lose nothing.
# the utility functions typically defined on foldables are specialized to lists,
# and what's more is they can be written using more expressive recursion schemes
# like paramorphisms
..def \tolist .thrush tolist \fldb
..def .thrush \tolist tolist \tolist
# the singleton foldable, folds to a singleton list of itself
..def .fldb \arg ..cons arg nil \single:fldb

..def \ftor \fldb \sequence ...veery ftor fldb sequence \tvsb
..def .thrush \ftor \fldb \sequence ftor \tvsb:ftor
..def .thrush \ftor \fldb \sequence fldb \tvsb:fldb
..def .thrush \ftor \fldb \sequence sequence \sequence

# `Distributive`, supposedly the categorical dual of `Traversable`
# distribute :: (Functor f, Distributive g) => f (g a) -> g (f a)
..def \ftor \distribute ..vireo ftor distribute \dstv
..def .thrush \ftor \distribute ftor \dstv:ftor
..def .thrush \ftor \distribute distribute \distribute

 # typeclass instances and utility functions

# catamorphisms, anamorphisms, hylomorphisms, paramorphisms, apomorphisms,
# histomorphisms and futumorphisms.
# data Fix f = Fix (f (Fix f))
# cata :: Functor f => (f a -> a) -> Fix f -> a
# ana :: Functor f => (a -> f a) -> a -> Fix f
# hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
# para :: Functor f => (f (Pair (Fix f) a) -> a) -> Fix f -> a
# apo :: Functor f => (a -> f (Either (Fix f) a)) -> a -> Fix f
# histo :: Functor f => (f (Cofree f a) -> a) -> Fix f -> a
# futu :: Functor f => (a -> f (Free f a)) -> a -> Fix f
# `..fmap ftor cata` doesn't depend on `init`, so when it gets unrolled during
# evaluation with a concrete `init`, it also gets unrolled in this definition,
# causing a space leak (more correctly, it gets unrolled not in this definition
# but in its specialization to a functor and algebra). to avoid this we create
# an artificial dependency on `init` using `..kite init`. the other morphisms
# get same treatment
..def \ftor \alg .fix \cata \init
  .alg ...fmap ftor ..kite init cata init
\cata
..def \ftor \coalg .fix \ana \seed
  ...fmap ftor ..kite seed ana .coalg seed
\ana
..def \ftor \alg \coalg .fix \hylo \seed
  .alg ...fmap ftor ..kite seed hylo .coalg seed
\hylo
..def \ftor \ralg .fix \para \init
  .ralg ...fmap ftor ..kite init ..starling pair para init
\para
..def \ftor \rcoalg .fix \apo \seed
  ...fmap ftor ..kite seed ..vireo ana id .rcoalg seed
\apo
..def \ftor \cvalg ..bluebird ann .fix \histo \init
  ...starling cofree cvalg ...fmap ftor ..kite init histo init
\histo
..def \ftor \cvcoalg .fix \futu \seed
  ..fix \rec ..fmap ftor ..kite seed ..vireo rec futu .cvcoalg seed
\futu

# `Monoid b => Monoid (a -> b)` by combining return values
..def \inner:sgrp .inner:sgrp \innersappend
  .sgrp \rhs \lhs \arg ..innersappend .rhs arg .lhs arg
\env:sgrp
..def \inner:mnid .inner:mnid ..bluebird mnid env:sgrp \env:mnid
# the environment monad, models computations that depend on a shared environment
..def .ftor bluebird \env:ftor
..def ...aptv env:ftor kestrel starling \env:aptv # liftA2 = phi
..def ..mnad env:aptv .cardinal violet \env:mnad # join = warbler
..def ..dstv
  env:ftor
  \outer:ftor .outer:ftor \outerfmap
    \ftorenv \env ..outerfmap .thrush env ftorenv
\env:dstv

..def .eq \rhs \lhs true \unit:eq
..def .eq \rhs \lhs void \void:eq
..def ..ord unit:eq \rhs \lhs et \unit:ord
..def ..ord void:eq \rhs \lhs void \void:ord
..def ..bndd unit unit \unit:bndd
..def ..bndd void void \void:bndd
..def .dbg \unit id \unit:dbg
..def .dbg \void $err \void:dbg
..def .seq \unit id \unit:seq
..def .seq \void $err \void:seq
..def .sgrp \rhs \lhs unit \unit:sgrp
..def .sgrp \rhs \lhs void \void:sgrp
..def ..mnid unit:sgrp unit \unit:mnid
..def ..mnid void:sgrp void \void:mnid

..def .eq
  \rhs \lhs ..rhs
    ..lhs true false
    ..lhs false true
\bool:eq
..def ..ord
  bool:eq
  \rhs \lhs ..rhs
    ..lhs et lt
    ..lhs gt et
\bool:ord
..def ..bndd true false \bool:bndd
..def .dbg \bool ..bool :1 :0 \bool:dbg
..def .seq \bool ..bool id id \bool:seq
# these are duplicates of `..min:mnid bool:ord bool:bndd` and `..max:mnid
# bool:ord bool:bndd`, but they're common enough to warrant special cases
..def .sgrp and \and:sgrp
..def .sgrp or \or:sgrp
..def .sgrp xor \xor:sgrp
..def ..mnid and:sgrp true \and:mnid
..def ..mnid or:sgrp false \or:mnid
..def ..mnid xor:sgrp false \xor:mnid

..def .eq
  \rhs \lhs ...rhs
    ...lhs true false false
    ...lhs false true false
    ...lhs false false true
\cmp:eq
..def ..ord
  cmp:eq
  \rhs \lhs ...rhs
    ...lhs et gt gt
    ...lhs lt et gt
    ...lhs lt lt et
\cmp:ord
..def ..bndd gt lt \cmp:bndd
..def .dbg \cmp ...cmp :< := :> \cmp:dbg
..def .seq \cmp ...cmp id id id \cmp:seq
..def .sgrp \rhs \lhs ...lhs lhs rhs lhs \cmp:sgrp
..def ..mnid cmp:sgrp et \cmp:mnid
# the reverse ordering, obtained by swapping arguments to `compare`
..def \inner:ord .inner:ord \innereq \innercompare
  ..ord innereq .cardinal innercompare
\down:ord
# the reverse bounding, obtained by swapping `top` and `bot`
..def \inner:bndd .inner:bndd \innertop \innerbot
  ..bndd innertop innerbot
\down:bndd

..def .ftor
  \func \optarg
    ..optarg ..bluebird some func none
\opt:ftor
..def ...aptv
  opt:ftor
  some
  \optfunc \optarg
    ..optfunc \func ...fmap opt:ftor func optarg none
\opt:aptv
..def ..mnad
  opt:aptv
  \optarg \func ..optarg func none
\opt:mnad
..def ...altv
  opt:aptv
  none
  \optrhs \optlhs ..optlhs some optrhs
\opt:altv
..def .fldb
  \optarg ...optarg cons id nil
\opt:fldb
..def ...tvsb
  opt:ftor
  opt:fldb
  \elem:aptv \optaptv ..optaptv
    ..fmap .aptv:ftor elem:aptv some
    ..pure elem:aptv none
\opt:tvsb
# `Semigroup a => Monoid (Maybe a)` by adjoining `Nothing` as neutral element
..def \inner:sgrp .inner:sgrp \innersappend
  .sgrp ..lifta2 opt:aptv innersappend
\optsgrp:sgrp
..def \inner:sgrp ..mnid .optsgrp:sgrp inner:sgrp none \optsgrp:mnid
# no need for `Data.Monoid.First a`, it'd be isomorphic to `Alt Maybe a` and to
# `Semigroup b => Modoid (Maybe b)` for `b ~ Data.Semigroup.First a`.
# no need for `Data.Monoid.Last a`, it'd be isomorphic to `Dual (Alt Maybe a)`
# and to `Semigroup b => Modoid (Maybe b)` for `b ~ Data.Semigroup.Last a`.
#
# these typeclass instances need to be lazy in the element typeclass instance so
# we can take their fixed points to define the equivalent instances for `nat`
..def \elem:eq .eq
  \rhs \lhs ..rhs
    ..lhs .cardinal .equal elem:eq .kestrel false
    ..lhs .kestrel false true
\opt:eq
..def \elem:ord ..ord
  .opt:eq .ord:eq elem:ord
  \rhs \lhs ..rhs
    ..lhs .cardinal .compare elem:ord .kestrel lt
    ..lhs .kestrel gt et
\opt:ord
..def \elem:bndd ..bndd .some .top elem:bndd none \opt:bndd
..def \inner:dbg .dbg
  \opt ..opt ..blackbird :S .debug inner:dbg :N
\opt:dbg
..def \elem:seq \opt ..opt .force elem:seq id \opt:seq
# `type Every a = Down (Maybe (Down a))`
# the ordering where `Nothing` is the top element instead of the bottom element
..def \elem:ord .down:ord .opt:ord .down:ord elem:ord \every:ord
..def \elem:bndd .down:bndd .opt:bndd .down:bndd elem:bndd \every:bndd

# the "base" functor for `nat`, with the property `Fix NatF = Nat`.
# `data NatF a = Succ a | Zero deriving Functor`
..def .ftor
  \func \natfarg ..natfarg ..bluebird succ func zero
\natf:ftor
..def .fix opt:eq \nat:eq
..def .fix opt:ord \nat:ord
..def .fix opt:bndd \nat:bndd # zero, fix succ
..def .fix opt:dbg \nat:dbg
..def .fix opt:seq \nat:seq
..def opt:ftor \nat:ftor
..def opt:aptv \nat:aptv
..def opt:mnad \nat:mnad
..def opt:altv \nat:altv
..def opt:fldb \nat:fldb
..def opt:tvsb \nat:tvsb
..def \rhs \lhs ...cata natf:ftor ..vireo succ lhs rhs \add
..def \rhs \lhs ...cata natf:ftor ..vireo .add lhs zero rhs \mul
..def \rhs \lhs ...cata natf:ftor ..vireo .mul lhs .succ zero rhs \exp
..def \rhs \lhs ...cata natf:ftor ..vireo ..cardinal exp lhs .succ zero rhs \tet
..def ..cata natf:ftor ..vireo not true \even
..def ..cata natf:ftor ..vireo not false \odd
..def .sgrp add \add:sgrp
..def .sgrp mul \mul:sgrp
..def ..mnid add:sgrp zero \add:mnid
..def ..mnid mul:sgrp .succ zero \mul:mnid

..def \ok:eq \err:eq .ok:eq \okequal .err:eq \errequal
  .eq
    \rhs \lhs ..rhs
      ..lhs .cardinal okequal \err \ok false
      ..lhs \ok \err false .cardinal errequal
\res:eq
..def \ok:ord \err:ord .ok:ord \ok:eq \okcompare .err:ord \err:eq \errcompare
  ..ord
    ..res:eq ok:eq err:eq
    \rhs \lhs ..rhs
      ..lhs .cardinal okcompare \err \ok lt
      ..lhs \ok \err gt .cardinal errcompare
\res:ord
..def \ok:bndd \err:bndd ..bndd .ok .top ok:bndd .err .bot err:bndd \res:bndd
..def \ok:dbg \err:dbg .ok:dbg \okdebug .err:dbg \errdebug
  .dbg \res ..res ..blackbird :O okdebug ..blackbird :E errdebug
\res:dbg
..def \ok:seq \err:seq .ok:seq \okforce .err:seq \errforce
  .seq \res ..res okforce errforce
\res:seq
..def .sgrp \rhs \lhs ..lhs ok rhs \res:sgrp
..def .ftor
  \okfunc \resarg
    ..resarg ..bluebird ok okfunc err
\resb:ftor
..def ...aptv
  resb:ftor
  \arg .ok arg
  \resfunc \resarg
    ..resfunc \func ...fmap resb:ftor func resarg err
\resb:aptv
..def ..mnad
  resb:aptv
  \resarg \func ..resarg func err
\resb:mnad
..def .fldb
  \resarg ...resarg cons id .kestrel nil
\resb:fldb
..def ...tvsb
  resb:ftor
  resb:fldb
  \ok:aptv \resaptv ..resaptv
    ..fmap .aptv:ftor ok:aptv ok
    ..bluebird .pure ok:aptv err
\resb:tvsb
..def \res .cardinal res \flip

# type Flip a b = Either b a
#
# the ordering obtained by flipping elements of the either ordering
..def \err:eq \ok:eq .eq
  \rhs \lhs
    ....res:eq err:eq ok:eq
      .flip rhs
      .flip lhs
\flip:eq
..def \err:ord \ok:ord
  .err:ord \err:eq \errcompare .ok:ord \ok:eq \okcompare
    ..ord
      ..flip:eq err:eq ok:eq
      \rhs \lhs
        ....res:ord err:ord ok:ord
          .flip rhs
          .flip lhs
\flip:ord
# the bounding obtained by flipping elements of the either bounding
..def \err:bndd \ok:bndd
  ..res:bndd err:bndd ok:bndd
\flip:bndd
# the debugging obtained by flipping elements of the either debugging
..def \err:dbg \ok:dbg
  \res ..debug ..res:dbg err:dbg ok:dbg .flip res
\flip:dbg
# the sequencing obtained by flipping elements of the either sequencing
..def \err:seq \ok:seq
  \res ..force ..res:seq err:seq ok:seq .flip res
\flip:seq
# the monad obtained by flipping elements of the either monad
..def .ftor
  \errfunc \resarg .flip
    ...fmap resb:ftor errfunc
      .flip resarg
\flipb:ftor
..def ...aptv
  flipb:ftor
  \errarg .flip
    ..pure resb:aptv
      errarg
  \resfunc \resarg .flip
    ...apply resb:aptv
      .flip resfunc
      .flip resarg
\flipb:aptv
..def ..mnad
  flipb:aptv
  \resarg \errfunc .flip
    ...bind resb:mnad
      .flip resarg
      ..bluebird flip errfunc
\flipb:mnad
..def .fldb
  \resarg ..tolist resb:fldb .flip resarg
\flipb:fldb
..def ...tvsb
  flipb:ftor
  flipb:fldb
  \err:aptv \resaptv ...fmap .aptv:ftor err:aptv flip
    ...sequence resb:tvsb err:aptv .flip resaptv
\flipb:tvsb

# type Dbl a = Either a a
..def .warbler res:eq \dbl:eq
..def .warbler res:ord \dbl:ord
..def .warbler res:bndd \dbl:bndd
..def .warbler res:dbg \dbl:dbg
..def .warbler res:seq \dbl:seq
# no need for `Monoid a => Monoid (Dbl a)`, it'd be isomorphic to
# `(Applicative f, Monoid a) => Monoid (Ap f a)` for `f ~ Dbl`
..def .ftor
  \func \dblarg
    ..dblarg ..bluebird ok func ..bluebird err func
\dbl:ftor
# the Applicative and Monad instances are similar to those for `Pair Bool`, in
# that information about whether the contents came from `Left` or `Right` is
# combined using a monoid
..def \bool:mnid .bool:mnid \bool:sgrp \boolmempty .bool:sgrp \boolsappend
  ...aptv
    dbl:ftor
    \arg ...boolmempty ok err arg
    \dblfunc \dblarg
      .....boolsappend ..phi dblfunc kestrel ..phi dblarg kestrel
      ok err ...dblfunc id id ..dblarg id id
\dbl:aptv
..def \bool:mnid .bool:mnid \bool:sgrp \boolmempty .bool:sgrp \boolsappend
  ..mnad
    .dbl:aptv bool:mnid
    \dblarg \func
      ..def .func ..dblarg id id \dblret
      .....boolsappend ..phi dblarg kestrel ..phi dblret kestrel
      ok err ..dblret id id
\dlb:mnad
..def .fldb
  \dblarg ..cons ..dblarg id id nil
\dbl:fldb
..def ...tvsb
  dbl:ftor
  dbl:fldb
  \elem:aptv \dblaptv ..dblaptv
    ..fmap .aptv:ftor elem:aptv ok
    ..fmap .aptv:ftor elem:aptv err
\dbl:tvsb
..def \dbl ..pair ..phi dbl kestrel ..dbl id id \dbl.dual
..def .thrush \fst \snd ...fst ok err snd \pairbool.dual

# these typeclass instances need to be lazy in the element typeclass instance so
# we can take their fixed points to define the equivalent instances for `stream`
..def \fst:eq \snd:eq
  .eq
    \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
      ...sappend and:sgrp # and
        ...equal snd:eq rhssnd lhssnd
        ...equal fst:eq rhsfst lhsfst
\pair:eq
..def \fst:ord \snd:ord
  ..ord
    ..pair:eq .ord:eq fst:ord .ord:eq snd:ord
    \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
      ...sappend cmp:sgrp
        ...compare snd:ord rhssnd lhssnd
        ...compare fst:ord rhsfst lhsfst
\pair:ord
..def \fst:bndd \snd:bndd
  ..bndd
    ..pair .top fst:bndd .top snd:bndd
    ..pair .bot fst:bndd .bot snd:bndd
\pair:bndd
..def \fst:dbg \snd:dbg
  .dbg
    \pair .pair \fst \snd
      ...becard ..debug fst:dbg fst :, ..debug snd:dbg snd
\pair:dbg
..def \fst:dbg \snd:dbg
  .seq
    \pair .pair \fst \snd
      ..bluebird ..force fst:dbg fst ..force snd:dbg snd
\pair:seq
..def \fst:sgrp \snd:sgrp
  .sgrp
    \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
      ..pair
        ...sappend fst:sgrp rhsfst lhsfst
        ...sappend fst:sgrp rhssnd lhssnd
\pair:sgrp
..def \fst:mnid \snd:mnid
  ..mnid
    ..pair:sgrp .mnid:sgrp fst:mnid .mnid:sgrp snd:mnid
    ..pair .mempty fst:mnid .mempty snd:mnid
\pair:mnid
..def .ftor \sndfunc \pairarg
  .pairarg \fstarg \sndarg
    ..pair fstarg .sndfunc sndarg
\paira:ftor
..def \fst:mnid .fst:mnid \fst:sgrp \fstmempty .fst:sgrp \fstsappend
  ...aptv
    paira:ftor
    \sndarg ..pair fstmempty sndarg
    \pairfunc \pairarg .pairfunc \fstfunc \sndfunc .pairarg \fstarg \sndarg
      ..pair ..fstsappend fstarg fstfunc .sndfunc sndarg
\paira:aptv
..def \fst:mnid .fst:mnid \fst:sgrp \fstmempty .fst:sgrp \fstsappend
  ..mnad
    .paira:aptv fst:mnid
    \pairarg \sndfunc .pairarg \fstarg \sndarg
      ..sndfunc sndarg \fstret \sndret
        ..pair ..fstsappend fstret fstarg sndret
\paira:mnad
..def .fldb
  \pairarg .pairarg \fst \snd ..cons snd nil
\paira:fldb
..def ...tvsb
  paira:ftor
  paira:fldb
  \snd:aptv \pairaptv .pairaptv ..bluebird .fmap .aptv:ftor snd:aptv pair
\paira:tvsb
..def \pair ..bluebird pair cardinal \swap

# type Swap a b = Pair b a
#
# the ordering obtained by swapping elements of the pair ordering
..def \snd:eq \fst:eq .eq
  \rhs \lhs
    ....pair:eq snd:eq fst:eq
      .swap rhs
      .swap lhs
\swap:eq
..def \snd:ord \fst:ord
  .snd:ord \snd:eq \sndcompare .fst:ord \fst:eq \fstcompare
    ..ord
      ..swap:eq snd:eq fst:eq
      \rhs \lhs
        ....pair:ord snd:ord fst:ord
          .swap rhs
          .swap lhs
\swap:ord
# the bounding obtained by swapping elements of the pair bounding
..def \snd:bndd \fst:bndd
  ..pair:bndd snd:bndd fst:bndd
\swap:bndd
# the debugging obtained by swapping elements of the pair debugging
..def \snd:dbg \fst:dbg .dbg
  \pair ..debug ..pair:dbg snd:dbg fst:dbg .swap pair
\swap:dbg
# the sequencing obtained by swapping elements of the pair sequencing
..def \snd:seq \fst:seq .seq
  \pair ..force ..pair:seq snd:seq fst:seq .swap pair
\swap:seq
# the monad obtained by swapping elements of the pair monad
..def .ftor
  \fstfunc \pairarg .swap
    ...fmap paira:ftor fstfunc
      .swap pairarg
\swapa:ftor
..def \snd:mnid ...aptv
  swapa:ftor
  \fstarg .swap
    ..pure .paira:aptv snd:mnid
      fstarg
  \pairfunc \pairarg .swap
    ...apply .paira:aptv snd:mnid
      .swap pairfunc
      .swap pairarg
\swapa:aptv
..def \snd:mnid ..mnad
  .swapa:aptv snd:mnid
  \pairarg \fstfunc .swap
    ...bind .paira:mnad snd:mnid
      .swap pairarg
      ..bluebird swap fstfunc
\swapa:mnad
..def .fldb
  \pairarg ..tolist paira:fldb .swap pairarg
\swapa:fldb
..def ...tvsb
  swapa:ftor
  swapa:fldb
  \fst:aptv \pairaptv ...fmap .aptv:ftor fst:aptv swap
    ...sequence paira:tvsb fst:aptv .swap pairaptv
\swapa:tvsb

# type Sqr a = Pair a a
..def .warbler pair:eq \sqr:eq
..def .warbler pair:ord \sqr:ord
..def .warbler pair:bndd \sqr:bndd
..def .warbler pair:dbg \sqr:dbg
..def .warbler pair:seq \sqr:seq
# no need for `Monoid a => Monoid (Sqr a)`, it'd be isomorphic to
# `(Applicative f, Monoid a) => Monoid (Ap f a)` for `f ~ Sqr`
..def .ftor
  \func \sqrarg .sqrarg \fstarg \sndarg
    ..pair .func fstarg .func sndarg
\sqr:ftor
..def ...aptv
  sqr:ftor
  \arg ..pair arg arg
  \sqrfunc \sqrarg .sqrfunc \fstfunc \sndfunc .sqrarg \fstarg \sndarg
    ..pair .fstfunc fstarg .sndfunc sndarg
\sqr:aptv
..def ..mnad
  sqr:aptv
  \sqrarg \func .sqrarg \fstarg \sndarg
    ..pair .fst .func fstarg .snd .func sndarg
\sqr:mnad
..def .fldb
  \sqrarg .sqrarg \fst \snd ..cons fst ..cons snd nil
\sqr:fldb
..def ...tvsb
  sqr:ftor
  sqr:fldb
  \elem:aptv \sqraptv .sqraptv ..lifta2 elem:aptv pair
\sqr:tvsb
..def ..dstv
  sqr:ftor
  unzip
\sqr:dstv

# type Stream a = Fix (Pair a)
..def paira:ftor \streamf:ftor
..def ..bluebird fix pair:eq \stream:eq
..def ..bluebird fix pair:ord \stream:ord
..def ..bluebird fix pair:bndd \stream:bndd
..def ..bluebird fix pair:dbg \stream:dbg
..def ..bluebird fix pair:seq \stream:seq # never terminates
..def ..bluebird fix pair:sgrp \stream:sgrp
..def ..bluebird fix pair:mnid \stream:mnid
..def .ftor
  \func ..cata streamf:ftor ..fmap swapa:ftor func
\stream:ftor
..def ...aptv
  stream:ftor
  \arg .fix .pair arg
  \streamfunc \streamarg ...ana streamf:ftor
    # almost a `swapa:aptv`, but `pair` the constructor does not induce a monoid
    \pair .pair \streamfunc \streamarg
      .streamfunc \fstfunc \sndfunc .streamarg \fstarg \sndarg
        ..pair .fstfunc fstarg ..pair sndfunc sndarg
    ..pair streamfunc streamarg
\stream:aptv
..def ..mnad
  stream:aptv
  \streamarg \func ...ana streamf:ftor
    # take the diagonal, same idea as `arr8:mnad`
    .thrush \fststream \sndstream
      ..pair .fst fststream ...fmap streamf:ftor snd sndstream
    ...fmap stream:ftor func streamarg
\stream:mnad
..def .fldb
  ..cata streamf:ftor .thrush cons
\stream:fldb
..def ...tvsb
  stream:ftor
  stream:fldb
  \elem:aptv ..cata streamf:ftor ..lifta2 elem:aptv pair
\stream:tvsb
..def ..dstv
  stream:ftor
  \outer:ftor .outer:ftor \outerfmap ..ana streamf:ftor
    \seed ....psi pair ..cardinal outerfmap seed fst snd
\stream:dstv
..def \func ..ana streamf:ftor
  \seed ..pair seed .func seed
\iterate
..def \list
  ...ana streamf:ftor ..vireo pair ..list pair $err list
\cycle
..def \pred ..cata streamf:ftor .thrush
  \fst \acc ...pred fst fst acc
\sfind
..def \pred ..cata streamf:ftor .thrush
  \fst \acc ...pred fst zero .succ acc
\sfindindex
..def \pred ..cata streamf:ftor .thrush
  \fst \acc ....pred head .pair zero id ...fmap stream:ftor succ acc
\sfindindices
..def \item:eq \item .sfind ..equal item:eq item \selem
..def \item:eq \item .sfindindex ..equal item:eq item \selemindex
..def \item:eq \item .sfindindices ..equal item:eq item \selemindices
..def \key:eq \key
  ..bluebird snd .sfind ..bluebird ..equal key:eq key fst
\slookup
# sinits :: Stream a -> Stream (List a)
# sinits1 :: Stream a -> Stream (List a)
# stails :: Stream a -> Stream (Stream a)
# stails1 :: Stream a -> Stream (Stream a)
..def ..cata streamf:ftor .thrush
  \fst \acc ..pair nil ...fmap stream:ftor .cons fst acc
\sinits
..def ..cata streamf:ftor .thrush
  \fst \acc ...fmap stream:ftor .cons fst ..pair nil acc
\sinits1
..def ..ana streamf:ftor .thrush
  \fst \snd ..pair ..pair fst snd snd
\stails
..def ..ana streamf:ftor .thrush
  \fst \snd ..pair ..pair fst snd snd
\stails1
..def \pred ..cata streamf:ftor .thrush
  \fst \acc ....pred fst .pair fst id acc
\sfilter
..def \aptv \predm ..cata streamf:ftor .thrush
  \fst \acc ....lifta2 aptv ..vireo .pair fst id .predm fst acc
\sfilterm
..def \pred ..cata streamf:ftor .thrush
  \fst \acc ...fmap ...pred fst swapa:ftor paira:ftor .pair fst acc
\spartition
..def \elem:eq ..cata streamf:ftor .thrush
  \fst \acc .acc \fstacc \sndacc
    .....equal elem:eq fst ..fstacc kestrel $err
      ..pair ..cons fst fstacc sndacc
      ..pair ..cons fst nil acc
\sgroup
# takeWhile :: (a -> Bool) -> Stream a -> List a
# dropWhile :: (a -> Bool) -> Stream a -> Stream a
# span :: (a -> Bool) -> Stream a -> Pair (List a) (Stream a)
# take :: Nat -> Stream a -> List a
# splitAt :: Nat -> Stream a -> Pair (List a) (Stream a)
# drop :: Nat -> Stream a -> Stream a
# (!?) :: Nat -> Stream a -> Maybe a
# windows :: Nat -> Stream a -> Stream (List a)
..def \pred ..cata streamf:ftor .thrush
  \fst \acc ...pred fst ..cons fst acc nil
\stakewhile
..def \pred ..para streamf:ftor .thrush
  \fst .thrush \snd \acc ...pred fst acc ..pair fst snd
\sdropwhile
..def \pred ..para streamf:ftor .thrush
  \fst .thrush \snd \acc ...pred fst
    .acc \take \drop ..pair ..cons fst take drop
    ..pair nil ..pair fst snd
\sspan
..def ..cata natf:ftor ..finch .kestrel nil
  \acc .thrush \fst \snd ..cons fst .acc snd
\stake
..def ..cata natf:ftor ..finch .pair nil
  \acc .thrush \fst \snd ...fmap swapa:ftor .cons fst .acc snd
\ssplitat
..def ..cata natf:ftor ..vireo .queerbird snd id \sdrop
..def ..cata natf:ftor ..vireo .queerbird snd fst \sat
..def \width \stream
  ...fmap stream:ftor .stake width .stails stream
\swindows
..def ..iterate succ zero \iota

# the "base" functor for `list`, with the property `Fix (ListF a) = List a`.
# `data ListF a b = Cons a b | Nil deriving Functor`
..def .ftor
  \func \listfarg ..listfarg \head \tail ..cons head .func tail nil
\listf:ftor
..def \elem:mnid .elem:mnid \sgrp \mempty .sgrp \sappend
  ..cata listf:ftor ..vireo sappend mempty
\fold
# no need for `Monoid (List a)`, it'd be isomorphic to `Alternative f =>
# Monoid (Alt f a)` for `f ~ List`
..def .ftor
  \func ..cata listf:ftor ..finch nil ..bluebird cons func
\list:ftor
..def ...aptv
  list:ftor
  \arg ..cons arg nil
  \listfunc \listarg ...cata listf:ftor ..finch nil
    # avoiding `fmap` for efficiency. notice the init is `acc` instead of `nil`
    \func \acc ...cata listf:ftor ..finch acc ..bluebird cons func listarg
    listfunc
\list:aptv
..def ..mnad
  list:aptv
  \listarg \func ...cata listf:ftor ..finch nil
    \arg \acc ...cata listf:ftor ..vireo cons acc .func arg
    listarg
\list:mnad
..def ...altv
  list:aptv
  nil
  \listrhs \listlhs
    ...cata listf:ftor ..vireo cons listrhs listlhs
\list:altv
..def .fldb
  \listarg listarg
\list:fldb
..def ...tvsb
  list:ftor
  list:fldb
  \elem:aptv ..cata listf:ftor ..vireo
    ..lifta2 elem:aptv cons
    ..pure elem:aptv nil
\list:tvsb
..def \elem:eq .elem:eq \elemequal
  .eq
    .fix \listequal \rhs \lhs
      .\conscons ..rhs
        ..lhs conscons .kestrel false
        ..lhs .kestrel false true
      \lhshead \lhstail \rhshead \rhstail
        ....elemequal rhshead lhshead
          ..listequal rhstail lhstail false
\list:eq
..def \elem:ord .elem:ord \elem:eq \elemcompare
  ..ord
    .list:eq elem:eq
    .fix \listcompare \rhs \lhs
      .\conscons ..rhs
        ..lhs conscons .kestrel lt
        ..lhs .kestrel gt et
      \lhshead \lhstail \rhshead \rhstail
        .....elemcompare rhshead lhshead
          lt ..listcompare rhstail lhstail gt
\list:ord
..def \elem:bndd ..bndd .fix .cons .top elem:bndd nil \list:bndd
..def \elem:dbg .elem:dbg \elemdebug .dbg
  ..cata listf:ftor ..finch :N \head \tail ...becard .elemdebug head :: tail
\list:dbg
..def \elem:seq .elem:seq \elemforce .seq
  ..cata listf:ftor ..finch id \head \tail ..bluebird .elemforce head tail
\list:seq
# `type Short a = Down (List (Down a))`
# the ordering where shorter lists compare greater than longer lists and where
# `Nil` is the top element instead of the bottom element
..def \elem:ord .down:ord .list:ord .down:ord elem:ord \short:ord
..def \elem:bndd .down:bndd .list:bndd .down:bndd elem:bndd \short:bndd
..def ..cata listf:ftor ..finch zero .kestrel succ \len
..def ..cata listf:ftor ..finch none \head \acc .some ..acc id head \last
..def ..cata listf:ftor ..finch none \head \acc .some ..acc .cons head nil \init
# rev list = appEndo (getDual (foldMap (Dual . Endo . cons) list)) nil
..def \list ...fold .dual:mnid endo:mnid ...fmap list:ftor cons list nil \rev
..def \elem ..ana natf:ftor ..vireo .cons elem nil \replicate
# cons the element onto the sorted list and `insert` will scooch it over
..def \elem:ord ..apo listf:ftor ..finch nil
  \head \tail ..tail
    \headtail \tailtail
      ...isgt ...compare elem:ord headtail head
        ..cons headtail .ok ..cons head tailtail
        ..cons head .err tail
    ..cons head .err tail
\insert
..def ..cata listf:ftor insert \inssort
..def \pred ..bluebird
  .fold .alt:mnid opt:altv
  ..fmap list:ftor \elem ...pred elem .some elem none
\find
..def \pred ..cata listf:ftor ..finch none
  \head \acc ...pred head .some zero ...fmap opt:ftor succ acc
\findindex
..def \pred ..cata listf:ftor ..finch nil
  \head \acc ....pred head .cons zero id ...fmap list:ftor succ acc
\findindices
..def \item:eq \item .find ..equal item:eq item \elem
..def \item:eq \item .findindex ..equal item:eq item \elemindex
..def \item:eq \item .findindices ..equal item:eq item \elemindices
..def \key:eq \key
  ..bluebird ..fmap opt:ftor snd .find ..bluebird ..equal key:eq key fst
\lookup
..def ..cata listf:ftor ..finch ..cons nil nil
  \head \acc ..cons nil ...fmap list:ftor .cons head acc
\inits
..def ..cata listf:ftor ..finch nil
  \head \acc ...fmap list:ftor .cons head ..cons nil acc
\inits1
..def ..ana listf:ftor ..finch ..cons nil nil
  \head \tail ..cons ..cons head tail tail
\tails
..def ..ana listf:ftor ..finch nil
  \head \tail ..cons ..cons head tail tail
\tails1
..def \pred ..cata listf:ftor ..finch nil
  \head \acc ....pred head .cons head id acc
\filter
..def \aptv \predm ..cata listf:ftor ..finch ..pure aptv nil
  \head \acc ....lifta2 aptv ..vireo .cons head id .predm head acc
\filterm
..def \pred ..cata listf:ftor ..finch ..pair nil nil
  \head \acc ...fmap ...pred head swapa:ftor paira:ftor .cons head acc
\partition
..def \elem:eq ..cata listf:ftor ..finch nil
  \head \acc ..acc
    \headacc \tailacc
      .....equal elem:eq head ..headacc kestrel $err
        ..cons ..cons head headacc tailacc
        ..cons ..cons head nil acc
    ..cons ..cons head nil acc
\group
# takeWhile :: (a -> Bool) -> List a -> List a
# dropWhile :: (a -> Bool) -> List a -> List a
# span :: (a -> Bool) -> List a -> Pair (List a) (List a)
# take :: Nat -> List a -> Maybe (List a)
# splitAt :: Nat -> List a -> Maybe (Pair (List a) (List a))
# drop :: Nat -> List a -> Maybe (List a)
# (!?) :: Nat -> List a -> Maybe a
# windows :: Nat -> List a -> List (List a)
..def \pred ..cata listf:ftor ..finch nil
  \head \acc ...pred head ..cons head acc nil
\takewhile
..def \pred ..para listf:ftor ..finch nil
  \head .thrush \tail \acc ...pred head acc ..cons head tail
\dropwhile
..def \pred ..para listf:ftor ..finch ..pair nil nil
  \head .thrush \tail \acc ...pred head
    .acc \take \drop ..pair ..cons head take drop
    ..pair nil ..cons head tail
\span
..def ..cata natf:ftor ..finch ..bluebird some .kestrel nil
  \acc ..finch none \head \tail ...fmap opt:ftor .cons head .acc tail
\take
..def ..cata natf:ftor ..finch ..bluebird some .pair nil
  \acc ..finch none
    \head \tail ...fmap opt:ftor ..fmap swapa:ftor .cons head .acc tail
\splitat
..def ..cata natf:ftor ..vireo ..kleisli opt:mnad tail some \drop
..def ..cata natf:ftor ..vireo ..kleisli opt:mnad tail head \at
..def \width \list
  ...bind list:mnad .tails list ..bluebird .tolist opt:fldb .take width
\windows

# `type DList a = List a -> List a`
# difference lists. a difference list is a function which, when given a tail,
# prepends the list it represents to that tail. concatenation of difference
# lists is function composition, which is constant time. `tolist` and `todlist`
# are linear time. see 'A Novel Representation of Lists and its Application to
# the Function "Reverse"' by John Hughes (1986)
..def .dove cons \dcons
..def id \dnil
..def ..cardinal blackbird cons \dsnoc
..def ..cata listf:ftor ..vireo dcons dnil \todlist
# no need for `Monoid (DList a)`, it'd be isomorphic to `Alternative f =>
# Monoid (Alt f a)` and to `Monoid (Endo (f a))` for `f ~ DList`
..def .ftor
  \func \dlistarg
    ...cata listf:ftor ..finch dnil ..bluebird dcons func .dlistarg nil
\dlist:ftor
..def ...aptv
  dlist:ftor
  \arg .dcons arg # aka \arg .bluebird .cons arg
  \dlistfunc \dlistarg ...cata listf:ftor
    ..finch dnil .dove ..cardinal .fmap dlist:ftor dlistarg
    .dlistfunc nil
\dlist:aptv
..def ..mnad
  dlist:aptv
  \dlistarg \func
    ...cata listf:ftor ..vireo .dove func dnil .dlistarg nil
\dlist:mnad
..def ...altv dlist:aptv dnil bluebird \dlist:altv
..def .fldb .thrush nil \dlist:fldb
..def ...tvsb
  dlist:ftor
  dlist:fldb
  \elem:aptv \dlistaptv
    ...cata listf:ftor ..vireo
      ..lifta2 elem:aptv dcons
      ..pure elem:aptv dnil
    .dlistaptv nil
\dlist:tvsb
..def \elem:eq .eq
  \rhs \lhs ...equal .list:eq elem:eq .rhs nil .lhs nil
\dlist:eq
..def \elem:ord ..ord
  .dlist:eq .ord:eq elem:ord
  \rhs \lhs ...compare .list:ord elem:ord .rhs nil .lhs nil
\dlist:ord
..def \elem:bndd ..bndd .fix .dcons .top elem:bndd dnil \dlist:bndd
# `type DShort a = Down (DList (Down a))`
# the ordering where shorter dlists compare greater than longer dlists and where
# `DNil` is the top element instead of the bottom element
..def \elem:ord .down:ord .dlist:ord .down:ord elem:ord \dshort:ord
..def \elem:bndd .down:bndd .dlist:bndd .down:bndd elem:bndd \dshort:bndd

# the "base" functor for `free`, with the property `Fix (FreeF f a) = Free f a`.
# `data FreeF f a r = Roll (f r) | Return a deriving Functor`
..def \term:ftor .term:ftor \termfmap
  .ftor
    \func \freefarg ..freefarg
      ..bluebird roll .termfmap func
      return
\freef:ftor
# `term:eq1` is a function that takes an `elem:eq` (an equality for the element
# type) and returns a `term:eq` (an equality for the collection). `term:ord1`
# works the same.
..def \term:eq1 \var:eq .fix \free:eq .var:eq \varequal
  .eq
    \rhs \lhs ..rhs
      ..lhs .equal .term:eq1 free:eq .kestrel false
      ..lhs .kestrel false varequal
\free:eq
..def \term:ord1 \var:ord .fix \free:ord .var:ord \var:eq \varcompare
  ..ord
    ..free:eq ..bluebird ord:eq term:ord1 var:eq
    \rhs \lhs ..rhs
      ..lhs .compare .term:ord1 free:ord .kestrel lt
      ..lhs .kestrel gt varcompare
\free:ord
..def \term:ftor \term:dbg1 \var:dbg
  ..term:dbg1 dbgged:dbg \termdebug .var:dbg \vardebug
    .dbg
      ..cata .freef:ftor term:ftor ..vireo
        ..blackbird :@ termdebug
        ..blackbird :$ vardebug
\free:dbg
..def \term:ftor \term:seq1 \var:seq
  ..term:seq1 forced:seq \termforce .var:seq \varforce
    .seq
      ..cata .freef:ftor term:ftor ..vireo termforce varforce
\free:seq
..def \term:ftor .ftor
  \func ..cata .freef:ftor term:ftor ..vireo roll
    ..bluebird return func
\free:ftor
..def \term:ftor ...aptv
  free:ftor
  \arg .return arg
  \freefunc \freearg
    ...cata .freef:ftor term:ftor ..vireo roll
      ..cardinal .fmap free:ftor freearg
    freefunc
\free:aptv
..def \term:ftor ..mnad
  free:aptv
  \freearg \func
    ...cata .freef:ftor term:ftor ..vireo roll
      func
    freearg
\free:mnad
# instance Foldable f => Foldable (Free f)
..def \term:fldb .term:fldb \termtolist
  .fldb
    # using `fix` instead of `cata` to save us requiring `term:ftor`
    .fix \freetolist \freearg ..freearg
      ..bluebird ..bind list:ftor freetolist termtolist
      .pure list:aptv
\free:fldb
# instance Traversable f => Traversable (Free f)
# sequence :: Applicative p => Free f (p a) -> p (Free f a)
..def \term:tvsb .term:tvsb \term:ftor \term:fldb \termsequence
  ...tvsb
    .free:ftor term:ftor
    .free:fldb term:fldb
    \elem:aptv ..cata .freef:ftor term:ftor ..vireo
      ..bluebird ..fmap .aptv:ftor elem:aptv roll .termsequence elem:aptv
      ..fmap .aptv:ftor elem:aptv return
\free:tvsb
# liftF :: Functor f => f a -> Free f a
# retract :: Monad f => Free f a -> f a
# hoistFree :: Functor f => (forall a. f a -> g a) -> Free f b -> Free g b
..def \term:ftor .term:ftor \termfmap
  ..bluebird roll .termfmap pure
\liftf
..def \term:mnad
  # in the `Roll` case we receive an `f r` where `r` is the carrier type, and
  # the carrier type itself is an `f a`, so we call `join :: f (f a) -> f a`
  ..cata .freef:ftor .aptv:ftor .mnad:aptv term:mnad ..vireo
    .join term:mnad
    .pure .mnad:aptv term:mnad
\retract
..def \term:ftor \func
  ..cata .freef:ftor term:ftor ..vireo
    ..bluebird roll func
    return
\hoistfree
# no need for `foldFree`, it'd be equivalent to `.cata freef:ftor`.
# no need for `unfoldFree`, it'd be equivalent to `.ana freef:ftor`.
# no need for `iter` and `iterA`, they'd be trivial wrappers over the above

# the "base" functor for `cofree`, with the property `Fix (CofreeF f a) =
# Cofree f a`. `data CofreeF f a r = Cofree (f r) a deriving Functor`
..def \trace:ftor .trace:ftor \tracefmap
  .ftor
    \func \cofreefarg
      .cofreefarg ..bluebird cofree .tracefmap func
\cofreef:ftor
..def \trace:eq1 \ann:eq .fix \cofree:eq
  .eq
    \rhs \lhs .rhs \rhstrace \rhsann .lhs \lhstrace \lhsann
      ...sappend and:sgrp # and
        ...equal ann:eq rhsann lhsann
        ...equal .trace:eq1 cofree:eq rhstrace lhstrace
\cofree:eq
..def \trace:ord1 \ann:ord .fix \cofree:ord
  ..ord
    ..cofree:eq ..bluebird ord:eq trace:ord1 .ord:eq ann:ord
    \rhs \lhs .rhs \rhstrace \rhsann .lhs \lhstrace \lhsann
      ...sappend cmp:sgrp
        ...compare ann:ord rhsann lhsann
        ...compare .trace:ord1 cofree:ord rhstrace lhstrace
\cofree:ord
..def \trace:ftor \trace:dbg1 \ann:dbg
  ..trace:dbg1 dbgged:dbg \tracedebug .ann:dbg \anndebug
    .dbg
      ..cata .cofreef:ftor trace:ftor .thrush
        \trace \ann ...becard .tracedebug trace :@ .anndebug ann
\cofree:dbg
..def \trace:ftor \trace:seq1 \ann:seq
  ..trace:seq1 forced:seq \traceforce .ann:seq \annforce
    .seq
      ..cata .cofreef:ftor trace:ftor .thrush
        \trace \ann ..bluebird .traceforce trace .annforce ann
\cofree:seq
..def \trace:ftor .ftor
  \func ..cata .cofreef:ftor trace:ftor .thrush
    \trace \ann ..cofree trace .func ann
\cofree:ftor
..def \trace:altv
  ..def .aptv:ftor .altv:aptv trace \trace:ftor
  ...aptv
    .cofree:ftor trace:ftor
    \arg ..cofree .empty .altv:aptv trace:altv arg
    \cofreefunc \cofreearg
      ...cata .cofreef:ftor trace:ftor .thrush
        \trace \ann ....fmap .cofree:ftor trace:ftor ann cofreearg
          ..bluebird cofree ..alt trace:altv trace
      cofreefunc
\cofree:aptv
..def \trace:altv
  ..def .aptv:ftor .altv:aptv trace \trace:ftor
  ..mnad
    .cofree:aptv .altv:aptv trace:altv
    \cofreearg \func
      ...cata .cofreef:ftor trace:ftor .thrush
        \trace \ann ..func ann
          ..bluebird cofree ..alt trace:altv trace
      cofreearg
\cofree:mnad
# instance Foldable f => Foldable (Cofree f)
..def \trace:fldb .trace:fldb \tracetolist
  .fldb
    # using `fix` instead of `cata` to save us requiring `trace:ftor`
    .fix \cofreetolist \cofreearg .cofreearg
      \trace \ann ..cons ann
        ...bind list:ftor cofreetolist .tracetolist trace
\cofree:fldb
# instance Traversable f => Traversable (Cofree f)
# sequence :: Applicative p => Cofree f (p a) -> p (Cofree f a)
..def \trace:tvsb .trace:tvsb \trace:ftor \trace:fldb \tracesequence
  ...tvsb
    .cofree:ftor trace:ftor
    .cofree:fldb trace:fldb
    \elem:aptv ..cata .cofreef:ftor trace:ftor .thrush
      \trace \ann ...fmap .aptv:ftor elem:aptv
        ..cardinal cofree ann
        ..tracesequence elem:aptv trace
\cofree:tvsb
# instance Distributive f => Distributive (Cofree f)
# distribute :: Functor g => g (Cofree f a) -> Cofree f (g a)
..def \trace:dstv .trace:dstv \trace:ftor \tracedistribute
  ..dstv
    .cofree:ftor trace:ftor
    \outer:ftor .outer:ftor \outerfmap
      ..ana .cofreef:ftor trace:ftor \seed ..cofree
        ..tracedistribute outer:ftor ..outerfmap trace seed
        ..outerfmap ann seed
\cofree:dstv

..def .ftor
  \func \arr8arg
    .arr8arg \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ........arr8
        .func a0
        .func a1
        .func a2
        .func a3
        .func a4
        .func a5
        .func a6
        .func a7
\arr8:ftor
..def ...aptv
  arr8:ftor
  \arg ........arr8 arg arg arg arg arg arg arg arg
  \arr8func \arr8arg
    .arr8func \f0 \f1 \f2 \f3 \f4 \f5 \f6 \f7
      .arr8arg \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
        ........arr8
          .f0 a0
          .f1 a1
          .f2 a2
          .f3 a3
          .f4 a4
          .f5 a5
          .f6 a6
          .f7 a7
\arr8:aptv
..def ..mnad
  arr8:aptv
  \arr8arg \func
    .arr8arg \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ........arr8
        .arr8.0 .func a0
        .arr8.1 .func a1
        .arr8.2 .func a2
        .arr8.3 .func a3
        .arr8.4 .func a4
        .arr8.5 .func a5
        .arr8.6 .func a6
        .arr8.7 .func a7
\arr8:mnad
..def .fldb
  \arr8arg
    .arr8arg \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ..cons a0
      ..cons a1
      ..cons a2
      ..cons a3
      ..cons a4
      ..cons a5
      ..cons a6
      ..cons a7
      nil
\arr8:fldb
..def ...tvsb
  arr8:ftor
  arr8:fldb
  \elem:aptv \arr8aptv
    .arr8aptv \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ..def .cardinal .apply elem:aptv \capply
      ..capply a7
      ..capply a6
      ..capply a5
      ..capply a4
      ..capply a3
      ..capply a2
      ..capply a1
      ..capply a0
      ..pure elem:aptv arr8
\arr8:tvsb
..def ..dstv
  arr8:ftor
  \outer:ftor .outer:ftor \outerfmap
    \ftorarr8 ........arr8
      ..outerfmap arr8.0 ftorarr8
      ..outerfmap arr8.1 ftorarr8
      ..outerfmap arr8.2 ftorarr8
      ..outerfmap arr8.3 ftorarr8
      ..outerfmap arr8.4 ftorarr8
      ..outerfmap arr8.5 ftorarr8
      ..outerfmap arr8.6 ftorarr8
      ..outerfmap arr8.7 ftorarr8
\arr8:dstv
..def \func \zero \arr8
  .arr8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    ..func
      ..func
        ..func
          ..func
            ..func
              ..func
                ..func
                  ..func
                    zero
                    a0
                  a1
                a2
              a3
            a4
          a5
        a6
      a7
\arr8.foldl
..def \func \zero \arr8
  .arr8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    ..func a0
      ..func a1
        ..func a2
          ..func a3
            ..func a4
              ..func a5
                ..func a6
                  ..func a7
                    zero
\arr8.foldr
..def \elem:eq .elem:eq \elemequal
  .eq
    \rhs \lhs ..fold and:mnid ..tolist arr8:fldb
      ....lifta2 arr8:aptv elemequal rhs lhs
\arr8:eq
..def \elem:ord .elem:ord \elem:eq \elemcompare
  ..ord
    .arr8:eq elem:eq
    \rhs \lhs ..fold cmp:mnid ..tolist arr8:fldb
      ....lifta2 arr8:aptv elemcompare rhs lhs
\arr8:ord
..def \elem:bndd .elem:bndd \elemtop \elembot
  ..bndd
    ..pure arr8:aptv elemtop
    ..pure arr8:aptv elembot
\arr8:bndd
..def \elem:dbg .elem:dbg \elemdebug
  .dbg
    \arr8 ..fold .dual:mnid endo:mnid ..tolist arr8:fldb
      ...fmap arr8:ftor elemdebug arr8
\arr8:dbg
..def \elem:seq .elem:seq \elemforce
  .seq
    \arr8 ..fold endo:mnid ..tolist arr8:fldb
      ...fmap arr8:ftor elemforce arr8
\arr8:seq

..def .arr8:eq bool:eq \u8:eq
..def .arr8:ord bool:ord \u8:ord
..def .arr8:bndd bool:bndd \u8:bndd
..def .arr8:dbg bool:dbg \u8:dbg
..def .arr8:seq bool:seq \u8:seq
..def .dbg
  \u8 .u8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    .\nibble ..bluebird
      ....nibble a7 a6 a5 a4
      ....nibble a3 a2 a1 a0
    \n3 \n2 \n1 \n0 ..n3
      ..n2 ..n1 ..n0 :f :e ..n0 :d :c ..n1 ..n0 :b :a ..n0 :9 :8
      ..n2 ..n1 ..n0 :7 :6 ..n0 :5 :4 ..n1 ..n0 :3 :2 ..n0 :1 :0
\u8.hex:dbg
# do case analysis on each bit, looking any bit at most once. `..and`, `..or`,
# `..and .not` and `..or .not` are special casees of case analysis where one
# branch short-circuits, so we allow those too
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..a6
    ..a4 # isalpha
      ..or .not a3 ..and .not a2 ..or .not a1 .not a0
      ..or a3 ..or a2 ..or a1 a0
    ..and a5 ..and a4 ..or .not a3 ..and .not a2 .not a1 # isdigit
\isalnum
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..and a6 ..a4
    ..or .not a3 ..and .not a2 ..or .not a1 .not a0
    ..or a3 ..or a2 ..or a1 a0
\isalpha
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..and .not a6 ..and .not a4 ..and .not a2 ..and .not a1 ..a5
    ..and .not a3 .not a0
    ..and a3 a0
\isblank
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..a6
    ..and a5 ..and a4 ..and a3 ..and a2 ..and a1 a0
    ..and .not a5 ..and .not a4 ..and .not a3
      ..and .not a2 ..and .not a1 .not a0 # !isprint
\iscntrl
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..and .not a6
    ..and a5 ..and a4 ..or .not a3 ..and .not a2 .not a1
\isdigit
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..a6
    ..or .not a5 ..or .not a4 ..or .not a3
      ..or .not a2 ..or .not a1 .not a0 # isprint
    ..and a5 ..or a4 ..or a3 ..or a2 ..or a1 a0
\isgraph
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..and a6 ..and a5 ..a4
    # isalpha
    ..or .not a3 ..and .not a2 ..or .not a1 .not a0
    ..or a3 ..or a2 ..or a1 a0
\islower
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..a6
    ..or .not a5 ..or .not a4 ..or .not a3
      ..or .not a2 ..or .not a1 .not a0
    a5
\isprint
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..a6
    ..a4
      ..and a3 ..a5
        ..or a2 ..and a1 a0
        ..a2
          ..and a1 a0
          ..or .not a1 .not a0
      ..and .not a3 ..and .not a2 ..and .not a1 .not a0
    ..and a5 ..a4
      ..and a3 ..or a2 a1
      ..or a3 ..or a2 ..or a1 a0
\ispunct
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..and .not a6 ..and .not a4 ..a5
    ..and .not a3 ..and .not a2 ..and .not a1 .not a0
    ..and a3 ..a2
      .not a1
      ..or a1 a0
\isspace
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..and a6 ..and .not a5 ..a4
    # isalpha
    ..or .not a3 ..and .not a2 ..or .not a1 .not a0
    ..or a3 ..or a2 ..or a1 a0
\isupper
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ..and .not a7 ..a6
    ..and .not a4 ..and .not a3 ..a2
      ..or .not a1 .not a0
      ..or a1 a0
    ..and a5 ..and a4 ..or .not a3 ..and .not a2 .not a1 # isdigit
\isxdigit
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  .not a7
\isascii
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ........arr8 a0 a1 true  a3 a4 a5 a6 a7
\mklower
..def .thrush \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
  ........arr8 a0 a1 false a3 a4 a5 a6 a7
\mkupper
..def \chr ...isupper chr .mklower chr chr \tolower
..def \chr ...islower chr .mkupper chr chr \toupper
..def \c \rhs \lhs
  ...arr8.foldl
    .thrush \c \arr8 .thrush \rhs \lhs
      ..pair
        ..or ..and c ..xor rhs lhs ..and rhs lhs
        .arr8 ..xor c ..xor rhs lhs
    ..pair c arr8
    # ...sequence sqr:tvsb arr8:aptv ..pair rhs lhs # works too
    ....lifta2 arr8:aptv pair rhs lhs
\u8.addc
..def \b \rhs \lhs
  ...arr8.foldl
    .thrush \b \arr8 .thrush \rhs \lhs
      ..pair
        ..or ..and b ..xor rhs .not lhs ..and rhs .not lhs
        .arr8 ..xor b ..xor rhs lhs
    ..pair b arr8
    # ...sequence sqr:tvsb arr8:aptv ..pair rhs lhs # works too
    ....lifta2 arr8:aptv pair rhs lhs
\u8.subb
..def \c \arg
  ...arr8.foldl
    .thrush \c \arr8 \cur
      ..pair
        ..and c cur
        .arr8 ..xor c cur
    ..pair c arr8
    arg
\u8.incc
..def \b \arg
  ...arr8.foldl
    .thrush \b \arr8 \cur
      ..pair
        ..and b .not cur
        .arr8 ..xor b cur
    ..pair b arr8
    arg
\u8.decb
..def ..blackbird snd .u8.addc false \u8.add
..def ..blackbird snd .u8.subb false \u8.sub
..def ..bluebird snd .u8.incc true \u8.inc
..def ..bluebird snd .u8.decb true \u8.dec
..def .sgrp u8.add \u8.add:sgrp
..def ..mnid u8.add:sgrp '\0' \u8.add:mnid

# an `IO a` is a function that takes a continuation and returns "$" functions
# wrapping the application of the continuation to a value of type `a`.
#
# no need for `Monoid a => Monoid (IO a)`, it'd be isomorphic to
# `(Applicative f, Monoid a) => Monoid (Ap f a)` for `f ~ IO`
..def .ftor
  \func \ioarg
    \cont .ioarg \arg .cont .func arg
\io:ftor
..def ...aptv
  io:ftor
  \arg
    \cont .cont arg
  \iofunc \ioarg
    \cont .iofunc \func ....fmap io:ftor func ioarg cont
\io:aptv
..def ..mnad
  io:aptv
  \ioarg \func
    \cont .ioarg \arg ..func arg cont
\io:mnad
# "$" functions like `$put` expect a continuation that takes no arguments, so
# we make wrappers of type `IO ()` that expect continuations that take a `unit`.
# similarly, functions like `$exit` expect no continuation, so we make wrappers
# of type `IO Void` that throw away the continuation.
..def \cont $exit \exit
..def \cont $err \#err # would shadow `err` the data constructor
..def $get \get
..def \bit \cont ..$put bit .cont unit \put
..def \bit \cont ..$eput bit .cont unit \eput
..def \term \cont ..$dump term .cont unit \dump
# we define a function `main` that takes an `IO ()` and invokes it with the
# continuation `\unit $exit`, throwing away the `unit` and returninng `$exit`
# to ultimately terminate the program
..def \iounit .iounit \unit $exit \main
# a hook that dumps the top-level term just before its effect is executed
..def \term ..$dump term term \$hook
..def \cont .$hook .cont unit \hook
..def \put ..bluebird
  ..sequence arr8:tvsb io:aptv
  ..fmap arr8:ftor put
\putc
..def \putc ..bluebird
  ..sequence list:tvsb io:aptv
  ..fmap list:ftor putc
\puts
..def \puts \arg:dbg \arg
  .puts ...debug arg:dbg arg nil
\putd
..def .putc eput  \eputc
..def .puts eputc \eputs
..def .putd eputs \eputd
..def .putc put  \putc
..def .puts putc \puts
..def .putd puts \putd
..def ...fmap io:ftor
  ..sequence arr8:tvsb opt:aptv
  ...sequence arr8:tvsb io:aptv
    ..pure arr8:aptv get
\getc
..def .fix \gets
  ...bind io:mnad getc ..finch
    ..pure io:aptv nil
    \chr ...fmap io:ftor .cons chr gets
\gets
..def .fix \getln
  ...bind io:mnad getc ..finch
    ..pure io:aptv nil
    \chr ...fmap io:ftor .cons chr
      .....equal u8:eq '\n' chr
        ..pure io:aptv nil
        getln
\getln

# type String = List U8
# type Parser a = String -> Maybe (Pair a String)
..def .ftor
  \func \parserarg
    \inp ...fmap opt:ftor
      ..fmap swapa:ftor func
      .parserarg inp
\parser:ftor
..def ...aptv
  parser:ftor
  \arg
    \inp ..pure opt:aptv ..pair arg inp
  \parserfunc \parserarg
    \inp ...bind opt:mnad
      .parserfunc inp
      \pairfunc .pairfunc \func
        ...fmap parser:ftor func parserarg
\parser:aptv
..def ..mnad
  parser:aptv
  \parserarg \func
    \inp ...bind opt:mnad
      .parserarg inp
      \pairarg .pairarg func
\parser:mnad
..def ...altv
  parser:aptv
  \inp .pure opt:altv
  \parserrhs \parserlhs
    \inp ...alt opt:altv .parserrhs inp .parserlhs inp
\parser:altv
..def \pred ..finch none
  \head \tail ...not .pred head none
    .some ..pair head tail
\satp
..def ..vireo
  \head \tail none
  .some ..pair unit nil
\eofp
..def ..bluebird satp .bluebird not \unsatp
..def ..bluebird satp .equal u8:eq \chrp
..def ..bluebird satp .unequal u8:eq \nonchrp
..def .satp .kestrel true \getp
..def ..bluebird
  ..sequence list:tvsb parser:aptv
  ..fmap list:ftor chrp
\strp

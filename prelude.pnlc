# vim:tw=80:ft=pnlc:
.\p .p \x \f .f x \def

..def \x x \id
..def \x \y x \kestrel
..def \x \y y \kite
..def \x \f .f x \thrush
..def \x \y \f ..f x y \vireo
..def \x \y \z \f ...f x y z \veery # made this one up
..def \f .f f \mockingbird
..def \f \x ..f x x \warbler
..def \f \x \y ..f y x \cardinal
..def \f \g \x .f .g x \bluebird
..def \f \g \x \y .f ..g x y \blackbird
..def \f \x \g \y ..f x .g y \dove
..def \f \x \y \g \z ...f x y .g z \dickcissel
..def \f \g \x \h \y ..f .g x .h y \dovekies
..def \f \g \x ..f x .g x \starling
..def \f \g \x ..f .g x x \violet # -backed starling
..def \f \g \h \x ..f .g x .h x \phi
..def \f \g \x \y ..f .g x .g y \psi
..def \f .\x .f .x x \x .f .x x \fix

 # constructors and eliminators

..def $err \void
..def \x x \unit

# def:bool
..def \true \false true \true
..def \true \false false \false
..def ..vireo false true \not
..def \rhs \lhs ..rhs lhs rhs \and
..def \rhs \lhs ..rhs rhs lhs \or
..def \rhs \lhs ...rhs not id lhs \xor

# def:cmp
..def \lt \et \gt lt \lt
..def \lt \et \gt et \et
..def \lt \et \gt gt \gt
..def ...veery true false false \islt
..def ...veery false true false \iseq
..def ...veery false false true \isgt

# def:opt
..def \opt \some \none .some opt \some
..def \some \none none \none
..def ..vireo .kestrel true false \issome
..def ..vireo .kestrel false true \isnone
..def ..vireo id $err \unwrap

# def:nat
..def \pred \succ \zero .succ pred \succ
..def \succ \zero zero \zero
..def ..vireo .kestrel true false \issucc
..def ..vireo .kestrel false true \iszero
..def ..vireo some none \pred

..def \fst \snd ..vireo fst snd \pair
..def .thrush \fst \snd fst \fst
..def .thrush \fst \snd snd \snd

# def:res
..def \val \ok \err .ok val \ok
..def \val \ok \err .err val \err
..def ..vireo .kestrel true .kestrel false \isok
..def ..vireo .kestrel false .kestrel true \iserr
..def ..vireo some .kestrel none \getok
..def ..vireo .kestrel none some \geterr

# def:list
..def \head \tail \cons \nil ..cons head tail \cons
..def \cons \nil nil \nil
..def ..vireo \head \tail true false \iscons
..def ..vireo \head \tail false true \isnil
..def ..vireo \head \tail .some head none \head
..def ..vireo \head \tail .some tail none \tail

# def:free the free monad
..def \term \roll \return .roll term \roll
..def \var \roll \return .return var \return
..def ..vireo .kestrel true .kestrel false \isroll
..def ..vireo .kestrel false .kestrel true \isreturn
..def ..vireo some .kestrel none \term
..def ..vireo .kestrel none some \var

# the cofree comonad
..def \trace \ann ..vireo trace ann \cofree
..def .thrush \trace \ann trace \trace
..def .thrush \trace \ann ann \ann

# type Arr8 a = (a, a, a, a, a, a, a, a)
..def \0 \1 \2 \3 \4 \5 \6 \7 \arr8 ........arr8 0 1 2 3 4 5 6 7 \arr8
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 0 \arr8.0
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 1 \arr8.1
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 2 \arr8.2
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 3 \arr8.3
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 4 \arr8.4
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 5 \arr8.5
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 6 \arr8.6
..def .thrush \0 \1 \2 \3 \4 \5 \6 \7 7 \arr8.7

 # typeclass definitions

..def \equal .thrush equal \eq
..def .thrush \equal equal \equal
..def .thrush \equal ..blackbird not equal \unequal

..def \eq \compare ..vireo eq compare \ord
..def .thrush \eq \compare eq \ord:eq
..def .thrush \eq \compare compare \compare
..def \ord \rhs \lhs .eq
  ......compare ord rhs lhs false true false
\ord.eq
# return the left-hand side when the arguments compare equal
..def \ord \rhs \lhs ......compare ord rhs lhs lhs lhs rhs \min
..def \ord \rhs \lhs ......compare ord rhs lhs rhs lhs lhs \max
..def \ord .thrush .min ord \min:sgrp
..def \ord .thrush .max ord \max:sgrp
..def \ord \bndd .bndd \top \bot
  ..vireo .min:sgrp ord top
\min:mnid
..def \ord \bndd .bndd \top \bot
  ..vireo .max:sgrp ord bot
\max:mnid
# return the argument when it is equal to one or both bounds
..def \ord \lo \hi ..bluebird ..min ord hi ..max ord lo \clamp

..def \top \bot ..vireo top bot \bndd
..def .thrush \top \bot top \top
..def .thrush \top \bot bot \bot

..def \sappend .thrush sappend \sgrp
..def .thrush \sappend sappend \sappend
# dual semigroup, the semigroup obtained by swapping arguments to `sappend`
..def \inner:sgrp .inner:sgrp \sappend .sgrp .cardinal sappend \dual:sgrp
# can't use `cata` here because the `natf` endofunctor isn't defined yet
..def \sgrp \elem .fix \stimes \count
  ..count ..bluebird ..sappend sgrp elem stimes elem
\stimes

..def \sgrp \mempty ..vireo sgrp mempty \mnid
..def .thrush \sgrp \mempty sgrp \mnid:sgrp
..def .thrush \sgrp \mempty mempty \mempty
# dual monoid, the monoid obtained by swapping arguments to `sappend`
..def \inner:mnid .inner:mnid \sgrp .mnid .dual:sgrp sgrp \dual:mnid
..def \mnid \elem \count .mnid \sgrp \mempty
  ..count ..stimes sgrp elem mempty
\mtimes

..def \fmap .thrush fmap \ftor
..def .thrush \fmap fmap \fmap
..def \ftor ..bluebird .fmap ftor kestrel \fmapk

..def \ftor \pure \apply ...veery ftor pure apply \aptv
..def .thrush \ftor \pure \apply ftor \aptv:ftor
..def .thrush \ftor \pure \apply pure \pure
..def .thrush \ftor \pure \apply apply \apply
..def \aptv \func \fst \snd
  ...apply aptv
    ...fmap .aptv:ftor aptv func fst
    snd
\lifta2
..def \aptv ..lifta2 aptv thrush \rapply
# XXX why are these two so slow on the IO applicative?
# XXX --> because of `io:ftor`'s `fmap`. but why?
..def \aptv ..lifta2 aptv kestrel \seql
..def \aptv ..lifta2 aptv kite \seqr
..def \aptv \left \right \inner
  ...seqr aptv left ...seql aptv inner right
\between
# `(Applicative f, Monoid a) => Monoid (Ap f a)` by lifting the monoid pointwise
..def \aptv \inner:sgrp .inner:sgrp \innersappend
  .sgrp ..lifta2 aptv innersappend
\ap:sgrp
..def \aptv \inner:mnid .inner:mnid \inner:sgrp \innermempty
  ..mnid
    ..ap:sgrp aptv inner:sgrp
    ..pure aptv innermempty
\ap:mnid

..def \aptv \bind ..vireo aptv bind \mnad
..def .thrush \aptv \bind aptv \mnad:aptv
..def .thrush \aptv \bind bind \bind
..def \mnad \x \f ...bind mnad x .kestrel f \bindk
..def \mnad ..bind mnad id \join
..def \mnad \f \g \x ...bind mnad .f x g \kleisli
# the monoid of Kleisli endomorphisms under Kleisli composition
..def \mnad .sgrp .kleisli mnad \kendo:sgrp
..def \mnad ..mnid .kendo:sgrp mnad .pure .mnad:aptv mnad \kendo:mnid

..def \aptv \empty \alt ...veery aptv empty alt \altv
..def .thrush \aptv \empty \alt aptv \altv:aptv
..def .thrush \aptv \empty \alt empty \empty
..def .thrush \aptv \empty \alt alt \alt
..def \many1 \altv \val
  ...alt altv ..pure .altv:aptv altv nil ..many1 altv val
\many
..def \many \altv \val
  ....lifta2 .altv:aptv altv cons val ..many altv val
\many1
..def .fix ..bluebird many1 many
..def .fix ..bluebird many many1
\many \many1
..def \altv \sep \elem
  ....lifta2 .altv:aptv altv cons
    elem
    ..many altv ...seqr .altv:aptv altv sep elem
\sepby1
..def \altv \sep \elem
  ...alt altv
    ..pure .altv:aptv altv nil
    ...sepby1 altv sep elem
\sepby
..def \altv \val
  ...alt altv
    ..pure .altv:aptv altv none
    ...fmap .aptv:ftor .altv:aptv altv some val
\option
# the monoid induced by `alt`
..def \altv .sgrp .alt altv \alt:sgrp
..def \altv ..mnid alt:sgrp .empty altv \alt:mnid
# no need for `asum`, it'd be the same as `.fold .alt:mnid something:altn`

# "The Foldable class represents data structures that can be reduced to a
# summary value one element at a time." well that's the list catamorphism, so
# why not output the list directly and let the user consume it as they please?
# `foldr` and `tolist` are interdefinable and both are lazy, so we lose nothing.
# the utility functions typically defined on foldables are specialized to lists,
# and what's more is they can be written using more expressive recursion schemes
# like paramorphisms
..def \tolist .thrush tolist \fldb
..def .thrush \tolist tolist \tolist

# TODO get rid of arr8.fold[lr]
..def \ftor \fldb \sequence ...veery ftor fldb sequence \tvsb
..def .thrush \ftor \fldb \sequence ftor \tvsb:ftor
..def .thrush \ftor \fldb \sequence fldb \tvsb:fldb
..def .thrush \ftor \fldb \sequence sequence \sequence

 # utility functions and typeclass instances

# catamorphisms, anamorphisms, hylomorphisms, paramorphisms, apomorphisms,
# histomorphisms and futumorphisms.
# cata :: Functor f => (f a -> a) -> Fix f -> a
# ana :: Functor f => (a -> f a) -> a -> Fix f
# hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
# para :: Functor f => (f (Pair (Fix a) a) -> a) -> Fix f -> a
# apo :: Functor f => (a -> f (Either (Fix a) a)) -> a -> Fix f
# histo :: Functor f => (f (Cofree f a) -> a) -> Fix f -> a
# futu :: Functor f => (a -> f (Free f a)) -> a -> Fix f
# `..fmap ftor cata` doesn't depend on `init`, so when it gets unrolled during
# evaluation with a concrete `init`, it also gets unrolled in this definition,
# causing a space leak (more correctly, it gets unrolled not in this definition
# but in its specialization to a functor and algebra). to avoid this we create
# an artificial dependency on `init` using `..kite init`. the other morphisms
# get same treatment
..def \ftor \alg .fix \cata \init
  .alg ...fmap ftor ..kite init cata init
\cata
..def \ftor \coalg .fix \ana \seed
  ...fmap ftor ..kite seed ana .coalg seed
\ana
..def \ftor \alg \coalg .fix \hylo \seed
  .alg ...fmap ftor ..kite seed hylo .coalg seed
\hylo
..def \ftor \ralg .fix \para \init
  .ralg ...fmap ftor ..kite init ...phi pair id para init
\para
..def \ftor \rcoalg .fix \apo \seed
  ...fmap ftor ..kite seed ..vireo ana id .rcoalg seed
\apo
..def \ftor \cvalg ..bluebird ann .fix \histo \init
  ....phi cofree id cvalg ...fmap ftor ..kite init histo init
\histo
..def \ftor \cvcoalg .fix \futu \seed
  ..fix \rec ..fmap ftor ..kite seed ..vireo rec futu .cvcoalg seed
\futu

# the left-zero and right-zero semigroups over the carrier set
..def .sgrp kite \first:sgrp
..def .sgrp kestrel \last:sgrp
# the monoid of endomorphisms under composition
..def .sgrp bluebird \endo:sgrp
..def ..mnid endo:sgrp id \endo:mnid
# `Monoid b => Monoid (a -> b)` by combining return values
..def \inner:sgrp .inner:sgrp \innersappend
  .sgrp \rhs \lhs \arg ..innersappend .rhs arg .lhs arg
\env:sgrp
..def \inner:mnid .inner:mnid ..bluebird mnid env:sgrp \env:mnid
# the singleton foldable, folds to a singleton list of itself
..def .fldb \arg ..cons arg nil \single:fldb
# the const functor, whose `fmap` is a no-op. it is also the "base" functor for
# `solo`, with the property `Fix (Const a) = Solo a`.
# `data Const a b = Const a deriving Functor`
..def .ftor kestrel \const:ftor
# the identity monad
..def .ftor id \ident:ftor
..def ...aptv ident:ftor id id \ident:aptv
..def ..mnad ident:aptv .cardinal id \ident:mnad
# the environment monad, models computations that depend on a shared environment
..def .ftor bluebird \env:ftor
..def ...aptv env:ftor kestrel starling \env:aptv # liftA2 = phi
..def ..mnad env:aptv .cardinal violet \env:mnad # join = warbler

..def .eq \rhs \lhs true \unit:eq
..def .eq \rhs \lhs void \void:eq
..def ..ord unit:eq \rhs \lhs et \unit:ord
..def ..ord void:eq \rhs \lhs void \void:ord
..def ..bndd unit unit \unit:bndd
..def ..bndd void void \void:bndd
..def .sgrp \rhs \lhs unit \unit:sgrp
..def .sgrp \rhs \lhs void \void:sgrp
..def ..mnid unit:sgrp unit \unit:mnid
..def ..mnid void:sgrp void \void:mnid

..def .eq
  \rhs \lhs ..rhs
    ..lhs true false
    ..lhs false true
\bool:eq
..def ..ord
  bool:eq
  \rhs \lhs ..rhs
    ..lhs et lt
    ..lhs gt et
\bool:ord
..def ..bndd true false \bool:bndd
# these are duplicates of `..min:mnid bool:ord bool:bndd` and `..max:mnid
# bool:ord bool:bndd`, but they're common enough to warrant special cases
..def .sgrp and \and:sgrp
..def .sgrp or \or:sgrp
..def .sgrp xor \xor:sgrp
..def ..mnid and:sgrp true \and:mnid
..def ..mnid or:sgrp false \or:mnid
..def ..mnid xor:sgrp false \xor:mnid

..def .eq
  \rhs \lhs ...rhs
    ...lhs true false false
    ...lhs false true false
    ...lhs false false true
\cmp:eq
..def ..ord
  cmp:eq
  \rhs \lhs ...rhs
    ...lhs et gt gt
    ...lhs lt et gt
    ...lhs lt lt et
\cmp:ord
..def ..bndd gt lt \cmp:bndd
..def .sgrp \rhs \lhs ...lhs lhs rhs lhs \cmp:sgrp
..def ..mnid cmp:sgrp et \cmp:mnid
# the reverse ordering, obtained by swapping arguments to `compare`
..def \inner:ord .inner:ord \innereq \innercompare
  ..ord innereq .cardinal innercompare
\down:ord
# the reverse bounding, obtained by swapping `top` and `bot`
..def \inner:bndd .inner:bndd \innertop \innerbot
  ..bndd innertop innerbot
\down:bndd

..def .ftor
  \func \optarg
    ..optarg ..bluebird some func none
\opt:ftor
..def ...aptv
  opt:ftor
  some
  \optfunc \optarg
    ..optfunc \func ...fmap opt:ftor func optarg none
\opt:aptv
..def ..mnad
  opt:aptv
  \optarg \func ..optarg func none
\opt:mnad
..def ...altv
  opt:aptv
  none
  \optrhs \optlhs ..optlhs some optrhs
\opt:altv
..def .fldb
  \optarg ...optarg cons id nil
\opt:fldb
..def \elem:aptv ...tvsb
  opt:ftor
  opt:fldb
  \optarg ..optarg
    ..fmap .aptv:ftor elem:aptv some
    ..pure elem:aptv none
\opt:tvsb
# `Semigroup a => Monoid (Maybe a)` by adjoining `Nothing` as neutral element
..def \inner:sgrp .inner:sgrp \innersappend
  .sgrp ..lifta2 opt:aptv innersappend
\optsgrp:sgrp
..def \inner:sgrp ..mnid .optsgrp:sgrp inner:sgrp none \optsgrp:mnid
# no need for `Data.Monoid.First a`, it'd be isomorphic to `Alt Maybe a` and to
# `Semigroup b => Modoid (Maybe b)` for `b ~ Data.Semigroup.First a`.
# no need for `Data.Monoid.Last a`, it'd be isomorphic to `Dual (Alt Maybe a)`
# and to `Semigroup b => Modoid (Maybe b)` for `b ~ Data.Semigroup.Last a`.
#
# these typeclass instances need to be lazy in the element typeclass instance so
# we can take their fixed points to define the equivalent instances for `nat`
..def \elem:eq .eq
  \rhs \lhs ..rhs
    ..lhs .cardinal .equal elem:eq .kestrel false
    ..lhs .kestrel false true
\opt:eq
..def \elem:ord .elem:ord \elem:eq \elemcompare
  ..ord
    .opt:eq elem:eq
    \rhs \lhs ..rhs
      ..lhs .cardinal elemcompare .kestrel lt
      ..lhs .kestrel gt et
\opt:ord
..def \elem:bndd ..bndd .some .top elem:bndd none \opt:bndd
# `type Every a = Down (Maybe (Down a))`
# the ordering where `Nothing` is the top element instead of the bottom element
..def \elem:ord .down:ord .opt:ord .down:ord elem:ord \every:ord
..def \elem:bndd .down:bndd .opt:bndd .down:bndd elem:bndd \every:bndd

# the "base" functor for `nat`, with the property `Fix NatF = Nat`.
# `data NatF a = Succ a | Zero deriving Functor`
..def .ftor
  \func \natfarg ..natfarg ..bluebird succ func zero
\natf:ftor
..def .fix opt:eq \nat:eq
..def .fix opt:ord \nat:ord
..def .fix opt:bndd \nat:bndd # zero, fix succ
..def opt:ftor \nat:ftor
..def opt:aptv \nat:aptv
..def opt:altv \nat:altv
..def opt:mnad \nat:mnad
..def \rhs \lhs ...cata natf:ftor ..vireo succ lhs rhs \add
..def \rhs \lhs ...cata natf:ftor ..vireo .add lhs zero rhs \mul
..def \rhs \lhs ...cata natf:ftor ..vireo .mul lhs .succ zero rhs \exp
..def \rhs \lhs ...cata natf:ftor ..vireo ..cardinal exp lhs .succ zero rhs \tet
..def ..cata natf:ftor ..vireo not true \even
..def ..cata natf:ftor ..vireo not false \odd
..def .sgrp add \add:sgrp
..def .sgrp mul \mul:sgrp
..def ..mnid add:sgrp zero \add:mnid
..def ..mnid mul:sgrp .succ zero \mul:mnid

..def \ok:eq \err:eq .eq
  \rhs \lhs ..rhs
    ..lhs .cardinal .equal ok:eq \err \ok false
    ..lhs \ok \err false .cardinal .equal err:eq
\res:eq
..def \ok:ord \err:ord .ok:ord \ok:eq \okcompare .err:ord \err:eq \errcompare
  ..ord
    ..res:eq ok:eq err:eq
    \rhs \lhs ..rhs
      ..lhs .cardinal okcompare \err \ok lt
      ..lhs \ok \err gt .cardinal errcompare
\res:ord
..def \ok:bndd \err:bndd ..bndd .ok .top ok:bndd .err .bot err:bndd \res:bndd
..def .sgrp \rhs \lhs ..lhs ok rhs \res:sgrp
..def .ftor
  \okfunc \resarg
    ..resarg ..bluebird ok okfunc err
\resb:ftor
..def ...aptv
  resb:ftor
  \arg .ok arg
  \resfunc \resarg
    ..resfunc \func ...fmap resb:ftor func resarg err
\resb:aptv
..def ..mnad
  resb:aptv
  \resarg \func ..resarg func err
\resb:mnad
..def .fldb
  \resarg ...resarg cons id .kestrel nil
\resb:fldb
..def \ok:aptv ...tvsb
  resb:ftor
  resb:fldb
  \resarg ..resarg
    ..fmap .aptv:ftor ok:aptv ok
    ..bluebird .pure ok:aptv err
\resb:tvsb
..def \res .cardinal res \flip

# type Flip a b = Either b a
#
# the ordering obtained by flipping elements of the either ordering
..def \err:eq \ok:eq .eq
  \rhs \lhs
    ....res:eq err:eq ok:eq
      .flip rhs
      .flip lhs
\flip:eq
..def \err:ord \ok:ord
  .err:ord \err:eq \errcompare .ok:ord \ok:eq \okcompare
    ..ord
      ..flip:eq err:eq ok:eq
      \rhs \lhs
        ....res:ord err:ord ok:ord
          .flip rhs
          .flip lhs
\flip:ord
# the bounding obtained by flipping elements of the either bounding
..def \err:bndd \ok:bndd
  ..res:bndd err:bndd ok:bndd
\flip:bndd
# the monad obtained by flipping elements of the either monad
..def .ftor
  \errfunc \resarg .flip
    ...fmap resb:ftor errfunc
      .flip resarg
\flipb:ftor
..def ...aptv
  flipb:ftor
  \errarg .flip
    ..pure resb:aptv
      errarg
  \resfunc \resarg .flip
    ...apply resb:aptv
      .flip resfunc
      .flip resarg
\flipb:aptv
..def ..mnad
  flipb:aptv
  \resarg \errfunc .flip
    ...bind resb:mnad
      .flip resarg
      ..bluebird flip errfunc
\flipb:mnad
..def .fldb
  \resarg ..tolist resb:fldb .flip resarg
\flipb:fldb
..def \err:aptv ...tvsb
  flipb:ftor
  flipb:fldb
  \resarg ...fmap .aptv:ftor err:aptv flip
    ..sequence .resb:tvsb err:aptv .flip resarg
\flipb:tvsb

# type Dbl a = Either a a
..def .warbler res:eq \dbl:eq
..def .warbler res:ord \dbl:ord
..def .warbler res:bndd \dbl:bndd
# no need for `Monoid a => Monoid (Dbl a)`, it'd be isomorphic to
# `(Applicative f, Monoid a) => Monoid (Ap f a)` for `f ~ Dbl`
..def .ftor
  \func \dblarg
    ..dblarg ..bluebird ok func ..bluebird err func
\dbl:ftor
# the Applicative and Monad instances are similar to those for `Pair Bool`, in
# that information about whether the contents came from `Left` or `Right` is
# combined using a monoid
..def \bool:mnid .bool:mnid \bool:sgrp \boolmempty .bool:sgrp \boolsappend
  ...aptv
    dbl:ftor
    \arg ...boolmempty ok err arg
    \dblfunc \dblarg
      .....boolsappend ..phi dblfunc kestrel ..phi dblarg kestrel
      ok err ...dblfunc id id ..dblarg id id
\dbl:aptv
..def \bool:mnid .bool:mnid \bool:sgrp \boolmempty .bool:sgrp \boolsappend
  ..mnad
    .dbl:aptv bool:mnid
    \dblarg \func
      ..def .func ..dblarg id id \dblret
      .....boolsappend ..phi dblarg kestrel ..phi dblret kestrel
      ok err ..dblret id id
\dlb:mnad
..def .fldb
  \dblarg ..cons ..dblarg id id nil
\dbl:fldb
..def \elem:aptv ...tvsb
  dbl:ftor
  dbl:fldb
  \dblarg ..dblarg
    ..fmap .aptv:ftor elem:aptv ok
    ..fmap .aptv:ftor elem:aptv err
\dbl:tvsb
..def \dbl ..pair ..phi dbl kestrel ..dbl id id \dbl.dual
..def .thrush \fst \snd ...fst ok err snd \pairbool.dual

# XXX doc wrappers? currently:
#   - ap
#   - min
#   - max
#   - add
#   - sqr
#   - dbl
#   - flip
#   - swap
#   - endo
#   - kendo
#   - dual
#   - down
#   - every
#   - short
#   - dshort
#   - single
#   - const
#   - ident
#   - env

# TODO doc conventions:
#   - \rhs \lhs, for partial application
#   - meanings of :
#     --> swap:mnid means 'monoid under swap' whereas
#         and:mnid means 'monoid induced by `and`'
#   - terse typeclass names because manual resolution

..def \fst:eq \snd:eq .fst:eq \fstequal .snd:eq \sndequal
    .eq
      \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
        ...sappend and:sgrp # and
          ..sndequal rhssnd lhssnd
          ..fstequal rhsfst lhsfst
\pair:eq
..def \fst:ord \snd:ord
  .fst:ord \fst:eq \fstcompare .snd:ord \snd:eq \sndcompare
    ..ord
      ..pair:eq fst:eq snd:eq
      \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
        ...sappend cmp:sgrp
          ..sndcompare rhssnd lhssnd
          ..fstcompare rhsfst lhsfst
\pair:ord
..def \fst:bndd \snd:bndd .fst:bndd \fsttop \fstbot .snd:bndd \sndtop \sndbot
    ..bndd
      ..pair fsttop sndtop
      ..pair fstbot sndbot
\pair:bndd
..def \fst:sgrp \snd:sgrp .fst:sgrp \fstsappend .snd:sgrp \sndsappend
    .sgrp
      \rhs \lhs .rhs \rhsfst \rhssnd .lhs \lhsfst \lhssnd
        ..pair
          ..fstsappend rhsfst lhsfst
          ..sndsappend rhssnd lhssnd
\pair:sgrp
..def \fst:mnid \snd:mnid
  .fst:mnid \fst:sgrp \fstmempty .snd:mnid \snd:sgrp \sndmempty
    ..mnid
      ..pair:sgrp fst:sgrp snd:sgrp
      ..pair fstmempty sndmempty
\pair:mnid
..def .ftor \sndfunc \pairarg
  .pairarg \fstarg \sndarg
    ..pair fstarg .sndfunc sndarg
\paira:ftor
..def \fst:mnid .fst:mnid \fst:sgrp \fstmempty .fst:sgrp \fstsappend
    ...aptv
      paira:ftor
      \sndarg ..pair fstmempty sndarg
      \pairfunc \pairarg .pairfunc \fstfunc \sndfunc .pairarg \fstarg \sndarg
        ..pair ..fstsappend fstarg fstfunc .sndfunc sndarg
\paira:aptv
..def \fst:mnid .fst:mnid \fst:sgrp \fstmempty .fst:sgrp \fstsappend
    ..mnad
      .paira:aptv fst:mnid
      \pairarg \sndfunc .pairarg \fstarg \sndarg
        ..sndfunc sndarg \fstret \sndret
          ..pair ..fstsappend fstret fstarg sndret
\paira:mnad
..def .fldb
  \pairarg .pairarg \fst \snd ..cons snd nil
\paira:fldb
..def \snd:aptv ...tvsb
  paira:ftor
  paira:fldb
  \pairarg .pairarg ..bluebird .fmap .aptv:ftor snd:aptv pair
\paira:tvsb
..def \pair ..bluebird pair cardinal \swap

# type Swap a b = (b, a)
#
# the ordering obtained by swapping elements of the pair ordering
..def \snd:eq \fst:eq .eq
  \rhs \lhs
    ....pair:eq snd:eq fst:eq
      .swap rhs
      .swap lhs
\swap:eq
..def \snd:ord \fst:ord
  .snd:ord \snd:eq \sndcompare .fst:ord \fst:eq \fstcompare
    ..ord
      ..swap:eq snd:eq fst:eq
      \rhs \lhs
        ....pair:ord snd:ord fst:ord
          .swap rhs
          .swap lhs
\swap:ord
# the bounding obtained by swapping elements of the pair bounding
..def \snd:bndd \fst:bndd
  ..pair:bndd snd:bndd fst:bndd
\swap:bndd
# the monad obtained by swapping elements of the pair monad
..def .ftor
  \fstfunc \pairarg .swap
    ...fmap paira:ftor fstfunc
      .swap pairarg
\swapa:ftor
..def \snd:mnid ...aptv
  swapa:ftor
  \fstarg .swap
    ..pure .paira:aptv snd:mnid
      fstarg
  \pairfunc \pairarg .swap
    ...apply .paira:aptv snd:mnid
      .swap pairfunc
      .swap pairarg
\swapa:aptv
..def \snd:mnid ..mnad
  .swapa:aptv snd:mnid
  \pairarg \fstfunc .swap
    ...bind .paira:mnad snd:mnid
      .swap pairarg
      ..bluebird swap fstfunc
\swapa:mnad
..def .fldb
  \pairarg ..tolist paira:fldb .swap pairarg
\swapa:fldb
..def \fst:aptv ...tvsb
  swapa:ftor
  swapa:fldb
  \pairarg ...fmap .aptv:ftor fst:aptv swap
    ..sequence .paira:tvsb fst:aptv .swap pairarg
\swapa:tvsb

# type Sqr a = (a, a)
..def .warbler pair:eq \sqr:eq
..def .warbler pair:ord \sqr:ord
..def .warbler pair:bndd \sqr:bndd
# no need for `Monoid a => Monoid (Sqr a)`, it'd be isomorphic to
# `(Applicative f, Monoid a) => Monoid (Ap f a)` for `f ~ Sqr`
..def .ftor
  \func \sqrarg .sqrarg \fstarg \sndarg
    ..pair .func fstarg .func sndarg
\sqr:ftor
..def ...aptv
  sqr:ftor
  \arg ..pair arg arg
  \sqrfunc \sqrarg .sqrfunc \fstfunc \sndfunc .sqrarg \fstarg \sndarg
    ..pair .fstfunc fstarg .sndfunc sndarg
\sqr:aptv
..def ..mnad
  sqr:aptv
  \sqrarg \func .sqrarg \fstarg \sndarg
    ..pair .fst .func fstarg .snd .func sndarg
\sqr:mnad
..def .fldb
  \sqrarg .sqrarg \fst \snd ..cons fst ..cons snd nil
\sqr:fldb
..def \elem:aptv ...tvsb
  sqr:ftor
  sqr:fldb
  \sqrarg .sqrarg ..lifta2 elem:aptv pair
\sqr:tvsb

# the "base" functor for `list`, with the property `Fix (ListF a) = List a`.
# `data ListF a b = Cons a b | Nil deriving Functor`
..def .ftor
  \func \listfarg ..listfarg \head \tail ..cons head .func tail nil
\listf:ftor
..def \elem:mnid .elem:mnid \sgrp \mempty .sgrp \sappend
  ..cata listf:ftor ..vireo sappend mempty
\fold
# no need for `Monoid [a]`, it'd be isomorphic to `Alternative f =>
# Monoid (Alt f a)` for `f ~ []`
..def .ftor
  \func ..cata listf:ftor ..vireo ..bluebird cons func nil
\list:ftor
..def ...aptv
  list:ftor
  \arg ..cons arg nil
  \listfunc \listarg ...cata listf:ftor ..vireo
    # avoiding `fmap` for efficiency. notice the init is `acc` instead of `nil`
    \func \acc ...cata listf:ftor ..vireo ..bluebird cons func acc listarg
    nil
    listfunc
\list:aptv
..def ..mnad
  list:aptv
  \listarg \func ...cata listf:ftor ..vireo
    \arg \acc ...cata listf:ftor ..vireo cons acc .func arg
    nil
    listarg
\list:mnad
..def ...altv
  list:aptv
  nil
  \listrhs \listlhs
    ...cata listf:ftor ..vireo cons listrhs listlhs
\list:altv
..def .fldb
  \listarg listarg
\list:fldb
..def \elem:aptv ...tvsb
  list:ftor
  list:fldb
  ..cata listf:ftor ..vireo
    ..lifta2 elem:aptv cons
    ..pure elem:aptv nil
\list:tvsb
..def \elem:eq .elem:eq \elemequal
  .eq
    .fix \listequal \rhs \lhs
      ..def \lhshead \lhstail \rhshead \rhstail
        ....elemequal rhshead lhshead
          ..listequal rhstail lhstail false
      \conscons ..rhs
      ..lhs conscons .kestrel false
      ..lhs .kestrel false true
\list:eq
..def \elem:ord .elem:ord \elem:eq \elemcompare
  ..ord
    .list:eq elem:eq
    .fix \listcompare \rhs \lhs
      ..def \lhshead \lhstail \rhshead \rhstail
        .....elemcompare rhshead lhshead
          lt ..listcompare rhstail lhstail gt
      \conscons ..rhs
      ..lhs conscons .kestrel lt
      ..lhs .kestrel gt et
\list:ord
..def \elem:bndd ..bndd .fix .cons .top elem:bndd nil \list:bndd
# `type Short a = Down (List (Down a))`
# the ordering where shorter lists compare greater than longer lists and where
# `Nil` is the top element instead of the bottom element
..def \elem:ord .down:ord .list:ord .down:ord elem:ord \short:ord
..def \elem:bndd .down:bndd .list:bndd .down:bndd elem:bndd \short:bndd
..def ..cata listf:ftor ..vireo .kestrel succ zero \len
..def ..cata listf:ftor ..vireo \head \acc .some ..acc id head none \last
..def ..cata listf:ftor ..vireo \head \acc .some ..acc .cons head nil none \init
# rev list = appEndo (getDual (foldMap (Dual . Endo . cons) list)) nil
..def \list ...fold .dual:mnid endo:mnid ...fmap list:ftor cons list nil \rev
..def .fold .alt:mnid list:altv \concat
..def \item \item:eq ..bluebird
  .fold or:mnid
  ..fmap list:ftor ..equal item:eq item
\elem
..def \pred ..bluebird
  .fold .alt:mnid opt:altv
  ..fmap list:ftor \elem ...pred elem .some elem none
\find
..def \pred ..cata listf:ftor ..vireo
  \head \acc ....pred head .cons head id acc
  nil
\filter
..def \pred ..cata listf:ftor ..vireo
  \head \acc ...fmap ...pred head swapa:ftor paira:ftor .cons head acc
  ..pair nil nil
\partition
..def \pred ..cata listf:ftor ..vireo
  \head \acc ...pred head ..cons head acc nil
  nil
\takewhile
..def \pred ..para listf:ftor ..vireo
  \head .thrush \tail \acc ...pred head acc ..cons head tail
  nil
\dropwhile
..def \pred ..para listf:ftor ..vireo
  \head .thrush \tail \acc ...pred head
    .acc \fst \snd ..pair ..cons head fst snd
    ..pair nil ..cons head tail
  ..pair nil nil
\span
# TODO implement `cataM` https://youtu.be/Zw9KeP3OzpU?t=4039
# TODO rewrite these using `cataM`
..def ..cata natf:ftor ..vireo ..kleisli opt:mnad tail some \drop
..def ..cata natf:ftor ..vireo ..kleisli opt:mnad tail head \at
# TODO implement `take`
..def $err \take
# \f \list ..list \head \tail .some ..cons head .f tail none
..def ..starling cons ..ana listf:ftor ..vireo
  \head \tail ..cons tail tail
  nil
\tails
# TODO implement `inits`
..def \elem ..ana natf:ftor ..vireo .cons elem nil \replicate
..def \width \list
  ...bind list:mnad list ..bluebird .tolist opt:tvsb .take width
\windows
# cons the element onto the sorted list and `insert` will scooch it over
..def \elem:ord ..apo listf:ftor ..vireo
  \head \tail ..tail
    \tailhead \tailtail
      ...isgt ...compare elem:ord tailhead head
        ..cons tailhead .ok ..cons head tailtail
        ..cons head .err tail
    ..cons head .err tail
  nil
\insert
..def ..cata listf:ftor insert \inssort

# `type DList a = [a] -> [a]`
# difference lists. a difference list is a function which, when given a tail,
# prepends the list it represents to that tail. concatenation of difference
# lists is function composition, which is constant time. `tolist` and `todlist`
# are linear time. see 'A Novel Representation of Lists and its Application to
# the Function "Reverse"' by John Hughes (1986)
..def .dove cons \dcons
..def id \dnil
..def ..cardinal blackbird cons \dsnoc
..def ..cata listf:ftor ..vireo dcons dnil \todlist
# no need for `Monoid (DList a)`, it'd be isomorphic to `Alternative f =>
# Monoid (Alt f a)` and to `Monoid (Endo (f a))` for `f ~ DList`
..def .ftor
  \func \dlistarg
    ...cata listf:ftor ..vireo ..bluebird dcons func dnil .dlistarg nil
\dlist:ftor
..def ...aptv
  dlist:ftor
  \arg .dcons arg # aka \arg .bluebird .cons arg
  \dlistfunc \dlistarg ...cata listf:ftor
    ..vireo .dove ..cardinal .fmap dlist:ftor dlistarg dnil
    .dlistfunc nil
\dlist:aptv
..def ..mnad
  dlist:aptv
  \dlistarg \func
    ...cata listf:ftor ..vireo .dove func dnil .dlistarg nil
\dlist:mnad
..def ...altv dlist:aptv dnil bluebird \dlist:altv
..def .fldb .thrush nil \dlist:fldb
..def \elem:aptv ...tvsb
  dlist:ftor
  dlist:fldb
  \dlistarg ...cata listf:ftor ..vireo
      ..lifta2 elem:aptv dcons
      ..pure elem:aptv dnil
    .dlistarg nil
\dlist:tvsb
..def \elem:eq .eq
  \rhs \lhs ...equal .list:eq elem:eq .rhs nil .lhs nil
\dlist:eq
..def \elem:ord ..ord
  .dlist:eq .ord:eq elem:ord
  \rhs \lhs ...compare .list:ord elem:ord .rhs nil .lhs nil
\dlist:ord
..def \elem:bndd ..bndd .fix .dcons .top elem:bndd dnil \dlist:bndd
# `type DShort a = Down (DList (Down a))`
# the ordering where shorter dlists compare greater than longer dlists and where
# `DNil` is the top element instead of the bottom element
..def \elem:ord .down:ord .dlist:ord .down:ord elem:ord \dshort:ord
..def \elem:bndd .down:bndd .dlist:bndd .down:bndd elem:bndd \dshort:bndd

# the "base" functor for `free`, with the property `Fix (FreeF f a) = Free f a`.
# `data FreeF f a r = Roll (f r) | Return a deriving Functor`
..def \roll:ftor .roll:ftor \rollfmap
  .ftor
    \func \freefarg ..freefarg
      ..bluebird roll .rollfmap func
      return
\freef:ftor
..def \roll:ftor .roll:ftor \rollfmap
  .ftor
    .fix \freefmap \func \freearg ..freearg
      ..bluebird roll .rollfmap .freefmap func
      ..bluebird return func
\free:ftor
..def \roll:ftor .roll:ftor \rollfmap
  ...aptv
    free:ftor
    \arg .return arg
    .fix \freeapply \freefunc \freearg ..freefunc
      ..bluebird roll .rollfmap ..cardinal freeapply freearg
      ..cardinal .fmap free:ftor freearg
\free:aptv
..def \roll:ftor .roll:ftor \rollfmap
  ..mnad
    free:aptv
    .fix \freebind \freearg \func ..freearg
      ..bluebird roll .rollfmap ..cardinal freebind func
      func
\free:mnad

# the "base" functor for `cofree`, with the property `Fix (CofreeF f a) = Cofree
# f a`. `data CofreeF f a r = Cofree (f r) a deriving Functor`
..def \trace:ftor .trace:ftor \tracefmap
  .ftor
    \func \cofreefarg
      .cofreefarg ..bluebird cofree .tracefmap func
\cofreef:ftor
..def \trace:ftor .trace:ftor \tracefmap
  .ftor
    .fix \cofreefmap \func \cofreefarg .cofreefarg \trace \ann ..cofree
      ..tracefmap .cofreefmap func trace
      .func ann
\cofree:ftor

..def .ftor
  \func \arg8
    .arg8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ........arr8
        .func a0
        .func a1
        .func a2
        .func a3
        .func a4
        .func a5
        .func a6
        .func a7
\arr8:ftor
..def ...aptv
  arr8:ftor
  \arg ........arr8 arg arg arg arg arg arg arg arg
  \func8 \arg8
    .func8 \f0 \f1 \f2 \f3 \f4 \f5 \f6 \f7
      .arg8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
        ........arr8
          .f0 a0
          .f1 a1
          .f2 a2
          .f3 a3
          .f4 a4
          .f5 a5
          .f6 a6
          .f7 a7
\arr8:aptv
..def ..mnad
  arr8:aptv
  \arg8 \func
    .arg8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ........arr8
        .arr8.0 .func a0
        .arr8.1 .func a1
        .arr8.2 .func a2
        .arr8.3 .func a3
        .arr8.4 .func a4
        .arr8.5 .func a5
        .arr8.6 .func a6
        .arr8.7 .func a7
\arr8:mnad
..def .fldb
  \arg8
    .arg8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ..cons a0
      ..cons a1
      ..cons a2
      ..cons a3
      ..cons a4
      ..cons a5
      ..cons a6
      ..cons a7
      nil
\arr8:fldb
..def \elem:aptv ...tvsb
  arr8:ftor
  arr8:fldb
  \arg8
    .arg8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
      ..def .cardinal .apply elem:aptv \capply
      ..capply a7
      ..capply a6
      ..capply a5
      ..capply a4
      ..capply a3
      ..capply a2
      ..capply a1
      ..capply a0
      ..pure elem:aptv arr8
\arr8:tvsb
..def \func \zero \arr8
  .arr8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    ..func
      ..func
        ..func
          ..func
            ..func
              ..func
                ..func
                  ..func
                    zero
                    a0
                  a1
                a2
              a3
            a4
          a5
        a6
      a7
\arr8.foldl # TODO get rid of
..def \func \zero \arr8
  .arr8 \a0 \a1 \a2 \a3 \a4 \a5 \a6 \a7
    ..func a0
      ..func a1
        ..func a2
          ..func a3
            ..func a4
              ..func a5
                ..func a6
                  ..func a7
                    zero
\arr8.foldr # TODO get rid of
..def \elem:eq .elem:eq \elemequal
  .eq
    \rhs \lhs ..fold and:mnid ..tolist arr8:fldb
      ....lifta2 arr8:aptv elemequal rhs lhs
\arr8:eq
..def \elem:ord .elem:ord \elem:eq \elemcompare
  ..ord
    .arr8:eq elem:eq
    \rhs \lhs ..fold cmp:mnid ..tolist arr8:fldb
      ....lifta2 arr8:aptv elemcompare rhs lhs
\arr8:ord
..def \elem:bndd .elem:bndd \elemtop \elembot
  ..bndd
    ..pure arr8:aptv elemtop
    ..pure arr8:aptv elembot
\arr8:bndd

# type U8 = Arr8 Bool = (Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool)
..def ........arr8 false false false false false false false false \nul
..def ........arr8 true  false false false false false false false \soh
..def ........arr8 false true  false false false false false false \stx
..def ........arr8 true  true  false false false false false false \etx
..def ........arr8 false false true  false false false false false \eot
..def ........arr8 true  false true  false false false false false \enq
..def ........arr8 false true  true  false false false false false \ack
..def ........arr8 true  true  true  false false false false false \bel
..def ........arr8 false false false true  false false false false \bs
..def ........arr8 true  false false true  false false false false \ht
..def ........arr8 false true  false true  false false false false \lf
..def ........arr8 true  true  false true  false false false false \vt
..def ........arr8 false false true  true  false false false false \ff
..def ........arr8 true  false true  true  false false false false \cr
..def ........arr8 false true  true  true  false false false false \so
..def ........arr8 true  true  true  true  false false false false \si
..def ........arr8 false false false false true  false false false \dle
..def ........arr8 true  false false false true  false false false \dc1
..def ........arr8 false true  false false true  false false false \dc2
..def ........arr8 true  true  false false true  false false false \dc3
..def ........arr8 false false true  false true  false false false \dc4
..def ........arr8 true  false true  false true  false false false \nak
..def ........arr8 false true  true  false true  false false false \syn
..def ........arr8 true  true  true  false true  false false false \etb
..def ........arr8 false false false true  true  false false false \can
..def ........arr8 true  false false true  true  false false false \em
..def ........arr8 false true  false true  true  false false false \sub
..def ........arr8 true  true  false true  true  false false false \esc
..def ........arr8 false false true  true  true  false false false \fs
..def ........arr8 true  false true  true  true  false false false \gs
..def ........arr8 false true  true  true  true  false false false \rs
..def ........arr8 true  true  true  true  true  false false false \us
..def ........arr8 false false false false false true  false false \sp
..def ........arr8 true  false false false false true  false false \'!'
..def ........arr8 false true  false false false true  false false \'"'
..def ........arr8 true  true  false false false true  false false \'#'
..def ........arr8 false false true  false false true  false false \'$'
..def ........arr8 true  false true  false false true  false false \'%'
..def ........arr8 false true  true  false false true  false false \'&'
..def ........arr8 true  true  true  false false true  false false \'''
..def ........arr8 false false false true  false true  false false \'('
..def ........arr8 true  false false true  false true  false false \')'
..def ........arr8 false true  false true  false true  false false \'*'
..def ........arr8 true  true  false true  false true  false false \'+'
..def ........arr8 false false true  true  false true  false false \','
..def ........arr8 true  false true  true  false true  false false \'-'
..def ........arr8 false true  true  true  false true  false false \'.'
..def ........arr8 true  true  true  true  false true  false false \'/'
..def ........arr8 false false false false true  true  false false \'0'
..def ........arr8 true  false false false true  true  false false \'1'
..def ........arr8 false true  false false true  true  false false \'2'
..def ........arr8 true  true  false false true  true  false false \'3'
..def ........arr8 false false true  false true  true  false false \'4'
..def ........arr8 true  false true  false true  true  false false \'5'
..def ........arr8 false true  true  false true  true  false false \'6'
..def ........arr8 true  true  true  false true  true  false false \'7'
..def ........arr8 false false false true  true  true  false false \'8'
..def ........arr8 true  false false true  true  true  false false \'9'
..def ........arr8 false true  false true  true  true  false false \':'
..def ........arr8 true  true  false true  true  true  false false \';'
..def ........arr8 false false true  true  true  true  false false \'<'
..def ........arr8 true  false true  true  true  true  false false \'='
..def ........arr8 false true  true  true  true  true  false false \'>'
..def ........arr8 true  true  true  true  true  true  false false \'?'
..def ........arr8 false false false false false false true  false \'@'
..def ........arr8 true  false false false false false true  false \'A'
..def ........arr8 false true  false false false false true  false \'B'
..def ........arr8 true  true  false false false false true  false \'C'
..def ........arr8 false false true  false false false true  false \'D'
..def ........arr8 true  false true  false false false true  false \'E'
..def ........arr8 false true  true  false false false true  false \'F'
..def ........arr8 true  true  true  false false false true  false \'G'
..def ........arr8 false false false true  false false true  false \'H'
..def ........arr8 true  false false true  false false true  false \'I'
..def ........arr8 false true  false true  false false true  false \'J'
..def ........arr8 true  true  false true  false false true  false \'K'
..def ........arr8 false false true  true  false false true  false \'L'
..def ........arr8 true  false true  true  false false true  false \'M'
..def ........arr8 false true  true  true  false false true  false \'N'
..def ........arr8 true  true  true  true  false false true  false \'O'
..def ........arr8 false false false false true  false true  false \'P'
..def ........arr8 true  false false false true  false true  false \'Q'
..def ........arr8 false true  false false true  false true  false \'R'
..def ........arr8 true  true  false false true  false true  false \'S'
..def ........arr8 false false true  false true  false true  false \'T'
..def ........arr8 true  false true  false true  false true  false \'U'
..def ........arr8 false true  true  false true  false true  false \'V'
..def ........arr8 true  true  true  false true  false true  false \'W'
..def ........arr8 false false false true  true  false true  false \'X'
..def ........arr8 true  false false true  true  false true  false \'Y'
..def ........arr8 false true  false true  true  false true  false \'Z'
..def ........arr8 true  true  false true  true  false true  false \'['
..def ........arr8 false false true  true  true  false true  false \'\'
..def ........arr8 true  false true  true  true  false true  false \']'
..def ........arr8 false true  true  true  true  false true  false \'^'
..def ........arr8 true  true  true  true  true  false true  false \'_'
..def ........arr8 false false false false false true  true  false \'`'
..def ........arr8 true  false false false false true  true  false \'a'
..def ........arr8 false true  false false false true  true  false \'b'
..def ........arr8 true  true  false false false true  true  false \'c'
..def ........arr8 false false true  false false true  true  false \'d'
..def ........arr8 true  false true  false false true  true  false \'e'
..def ........arr8 false true  true  false false true  true  false \'f'
..def ........arr8 true  true  true  false false true  true  false \'g'
..def ........arr8 false false false true  false true  true  false \'h'
..def ........arr8 true  false false true  false true  true  false \'i'
..def ........arr8 false true  false true  false true  true  false \'j'
..def ........arr8 true  true  false true  false true  true  false \'k'
..def ........arr8 false false true  true  false true  true  false \'l'
..def ........arr8 true  false true  true  false true  true  false \'m'
..def ........arr8 false true  true  true  false true  true  false \'n'
..def ........arr8 true  true  true  true  false true  true  false \'o'
..def ........arr8 false false false false true  true  true  false \'p'
..def ........arr8 true  false false false true  true  true  false \'q'
..def ........arr8 false true  false false true  true  true  false \'r'
..def ........arr8 true  true  false false true  true  true  false \'s'
..def ........arr8 false false true  false true  true  true  false \'t'
..def ........arr8 true  false true  false true  true  true  false \'u'
..def ........arr8 false true  true  false true  true  true  false \'v'
..def ........arr8 true  true  true  false true  true  true  false \'w'
..def ........arr8 false false false true  true  true  true  false \'x'
..def ........arr8 true  false false true  true  true  true  false \'y'
..def ........arr8 false true  false true  true  true  true  false \'z'
..def ........arr8 true  true  false true  true  true  true  false \'{'
..def ........arr8 false false true  true  true  true  true  false \'|'
..def ........arr8 true  false true  true  true  true  true  false \'}'
..def ........arr8 false true  true  true  true  true  true  false \'~'
..def ........arr8 true  true  true  true  true  true  true  false \del
..def nul \'\0'
..def bel \'\a'
..def bs  \'\a'
..def ht  \'\t'
..def lf  \'\n'
..def vt  \'\v'
..def ff  \'\f'
..def cr  \'\r'
..def esc \'\e'
..def \' sp  \' # eg .putc .' '
..def .cons nul \:nul
..def .cons soh \:soh
..def .cons stx \:stx
..def .cons etx \:etx
..def .cons eot \:eot
..def .cons enq \:enq
..def .cons ack \:ack
..def .cons bel \:bel
..def .cons bs  \:bs
..def .cons ht  \:ht
..def .cons lf  \:lf
..def .cons vt  \:vt
..def .cons ff  \:ff
..def .cons cr  \:cr
..def .cons so  \:so
..def .cons si  \:si
..def .cons dle \:dle
..def .cons dc1 \:dc1
..def .cons dc2 \:dc2
..def .cons dc3 \:dc3
..def .cons dc4 \:dc4
..def .cons nak \:nak
..def .cons syn \:syn
..def .cons etb \:etb
..def .cons can \:can
..def .cons em  \:em
..def .cons sub \:sub
..def .cons esc \:esc
..def .cons fs  \:fs
..def .cons gs  \:gs
..def .cons rs  \:rs
..def .cons us  \:us
..def .cons sp  \:sp
..def .cons '!' \:!
..def .cons '"' \:"
..def .cons '#' \:#
..def .cons '$' \:$
..def .cons '%' \:%
..def .cons '&' \:&
..def .cons ''' \:'
..def .cons '(' \:(
..def .cons ')' \:)
..def .cons '*' \:*
..def .cons '+' \:+
..def .cons ',' \:,
..def .cons '-' \:-
..def .cons '.' \:.
..def .cons '/' \:/
..def .cons '0' \:0
..def .cons '1' \:1
..def .cons '2' \:2
..def .cons '3' \:3
..def .cons '4' \:4
..def .cons '5' \:5
..def .cons '6' \:6
..def .cons '7' \:7
..def .cons '8' \:8
..def .cons '9' \:9
..def .cons ':' \::
..def .cons ';' \:;
..def .cons '<' \:<
..def .cons '=' \:=
..def .cons '>' \:>
..def .cons '?' \:?
..def .cons '@' \:@
..def .cons 'A' \:A
..def .cons 'B' \:B
..def .cons 'C' \:C
..def .cons 'D' \:D
..def .cons 'E' \:E
..def .cons 'F' \:F
..def .cons 'G' \:G
..def .cons 'H' \:H
..def .cons 'I' \:I
..def .cons 'J' \:J
..def .cons 'K' \:K
..def .cons 'L' \:L
..def .cons 'M' \:M
..def .cons 'N' \:N
..def .cons 'O' \:O
..def .cons 'P' \:P
..def .cons 'Q' \:Q
..def .cons 'R' \:R
..def .cons 'S' \:S
..def .cons 'T' \:T
..def .cons 'U' \:U
..def .cons 'V' \:V
..def .cons 'W' \:W
..def .cons 'X' \:X
..def .cons 'Y' \:Y
..def .cons 'Z' \:Z
..def .cons '[' \:[
..def .cons '\' \:\
..def .cons ']' \:]
..def .cons '^' \:^
..def .cons '_' \:_
..def .cons '`' \:`
..def .cons 'a' \:a
..def .cons 'b' \:b
..def .cons 'c' \:c
..def .cons 'd' \:d
..def .cons 'e' \:e
..def .cons 'f' \:f
..def .cons 'g' \:g
..def .cons 'h' \:h
..def .cons 'i' \:i
..def .cons 'j' \:j
..def .cons 'k' \:k
..def .cons 'l' \:l
..def .cons 'm' \:m
..def .cons 'n' \:n
..def .cons 'o' \:o
..def .cons 'p' \:p
..def .cons 'q' \:q
..def .cons 'r' \:r
..def .cons 's' \:s
..def .cons 't' \:t
..def .cons 'u' \:u
..def .cons 'v' \:v
..def .cons 'w' \:w
..def .cons 'x' \:x
..def .cons 'y' \:y
..def .cons 'z' \:z
..def .cons '{' \:{
..def .cons '|' \:|
..def .cons '}' \:}
..def .cons '~' \:~
..def .cons del \:del
..def :nul \:\0
..def :bel \:\a
..def :bs  \:\a
..def :ht  \:\t
..def :lf  \:\n
..def :vt  \:\v
..def :ff  \:\f
..def :cr  \:\f
..def :esc \:\r
..def :sp  \: # eg .puts .:  nil
..def \c \rhs \lhs
  ...arr8.foldl
    .thrush \c \arr8 .thrush \rhs \lhs
      ..pair
        ..or ..and c ..xor rhs lhs ..and rhs lhs
        .arr8 ..xor c ..xor rhs lhs
    ..pair c arr8
    # ..sequence .sqr:tvsb arr8:aptv ..pair rhs lhs # works too
    ....lifta2 arr8:aptv pair rhs lhs
\u8.addc
..def \b \rhs \lhs
  ...arr8.foldl
    .thrush \b \arr8 .thrush \rhs \lhs
      ..pair
        ..or ..and b ..xor rhs .not lhs ..and rhs .not lhs
        .arr8 ..xor b ..xor rhs lhs
    ..pair b arr8
    # ..sequence .sqr:tvsb arr8:aptv ..pair rhs lhs # works too
    ....lifta2 arr8:aptv pair rhs lhs
\u8.subb
..def \c \arg
  ...arr8.foldl
    .thrush \c \arr8 \cur
      ..pair
        ..and c cur
        .arr8 ..xor c cur
    ..pair c arr8
    arg
\u8.incc
..def \b \arg
  ...arr8.foldl
    .thrush \b \arr8 \cur
      ..pair
        ..and b .not cur
        .arr8 ..xor b cur
    ..pair b arr8
    arg
\u8.decb
..def ..blackbird snd .u8.addc false \u8.add
..def ..blackbird snd .u8.subb false \u8.sub
..def ..bluebird snd .u8.incc true \u8.inc
..def ..bluebird snd .u8.decb true \u8.dec
..def .sgrp u8.add \u8.add:sgrp
..def ..mnid u8.add:sgrp '\0' \u8.add:mnid
..def .arr8:eq bool:eq \u8:eq
..def .arr8:ord bool:ord \u8:ord
..def .arr8:bndd bool:bndd \u8:bndd

# an `IO a` is a function that takes a continuation and returns "$" functions
# wrapping the application of the continuation to a value of type `a`.
#
# no need for `Monoid a => Monoid (IO a)`, it'd be isomorphic to
# `(Applicative f, Monoid a) => Monoid (Ap f a)` for `f ~ IO`
..def .ftor
  \func \ioarg
    \cont .ioarg \arg .cont .func arg
\io:ftor
..def ...aptv
  io:ftor
  \arg
    \cont .cont arg
  \iofunc \ioarg
    \cont .iofunc \func ....fmap io:ftor func ioarg cont
\io:aptv
..def ..mnad
  io:aptv
  \ioarg \func
    \cont .ioarg \arg ..func arg cont
\io:mnad
# "$" functions like `$put` expect a continuation that takes no arguments, so
# we make wrappers of type `IO ()` that expect continuations that take a `unit`.
# similarly, functions like `$exit` expect no continuation, so we make wrappers
# of type `IO Void` that throw away the continuation.
..def \cont $exit \exit
# ..def \cont $err \err # shadows `err` the data constructor
..def $get \get
..def \bit \cont ..$put bit .cont unit \put
..def \term \cont ..$dump term .cont unit \dump
# we define a function `main` that takes an `IO ()` and invokes it with the
# continuation `\unit $exit`, throwing away the `unit` and returninng `$exit`
# to ultimately terminate the program
..def \iounit .iounit \unit $exit \main
# a hook that dumps the top-level term just before its effect is executed
..def \term ..$dump term term \$hook
..def \cont .$hook .cont unit \hook
..def ..bluebird
  .sequence .arr8:tvsb io:aptv
  ..fmap arr8:ftor put
\putc
..def ..bluebird
  .sequence .list:tvsb io:aptv
  ..fmap list:ftor putc
\puts
..def ...fmap io:ftor
  .sequence .arr8:tvsb opt:aptv
  ..sequence .arr8:tvsb io:aptv
    ..pure arr8:aptv get
\getc
..def .fix \gets
  ...bind io:mnad getc ..vireo
    \chr ...fmap io:ftor .cons chr gets
    ..pure io:aptv nil
\gets
..def .fix \getln
  ...bind io:mnad getc ..vireo
    \chr ...fmap io:ftor .cons chr
      .....equal u8:eq '\n' chr
        ..pure io:aptv nil
        getln
    ..pure io:aptv nil
\getln

# type Parser a = String -> Maybe (a, String)
..def .ftor
  \func \parserarg
    \inp ...fmap opt:ftor
      ..fmap swapa:ftor func
      .parserarg inp
\parser:ftor
..def ...aptv
  parser:ftor
  \arg
    \inp ..pure opt:aptv ..pair arg inp
  \parserfunc \parserarg
    \inp ...bind opt:mnad
      .parserfunc inp
      \pairfunc .pairfunc \func
        ...fmap parser:ftor func parserarg
\parser:aptv
..def ..mnad
  parser:aptv
  \parserarg \func
    \inp ...bind opt:mnad
      .parserarg inp
      \pairarg .pairarg func
\parser:mnad
..def ...altv
  parser:aptv
  \inp .pure opt:altv
  \parserrhs \parserlhs
    \inp ...alt opt:altv .parserrhs inp .parserlhs inp
\parser:altv
..def \pred \inp ..inp
  \head \tail ...pred head
    .some ..pair head tail
    none
  none
\satp
..def \inp ..inp
  \head \tail none
  .some ..pair unit nil
\eofp
..def \chr
  .satp ..equal u8:eq chr
\chrp
..def \str
  ..sequence .list:tvsb parser:aptv
  ...fmap list:ftor chrp str
\strp
..def
  .satp .kestrel true
\getp

# vim:tw=80:ft=pnlc:
# inc:../prelude.pnlc

# data Tape = Tape (Stream U8) U8 (Stream U8) -- where:
# type Stream a = Fix (Pair a) -- where:
# data Fix f = Fix (f (Fix f))
..def \left \head \right \tape ...tape left head right \tape
..def \tape .tape \left \head \right left \left
..def \tape .tape \left \head \right head \head
..def \tape .tape \left \head \right right \right
# apply `func` to the `head`
..def .ftor
  \func \tape .tape \left \head \right \tape
    ...tape left .func head right
\tape:ftor
# an infinite tape of zeroes
..def ...tape
  .fix .pair '\0'u8
  '\0'u8
  .fix .pair '\0'u8
\0tape
..def \tape .tape \left \head \right \tape .right \fst \snd
  ...tape ..pair head left fst snd
\tape.shl
..def \tape .tape \left \head \right \tape .left \fst \snd
  ...tape snd fst ..pair head right
\tape.shr

# read characters from stdin until a '!'. we use the character '!' to separate
# the Brainfuck program from its input. that is, '!' ends a program string and
# and begins its execution
..def .fix \getbang
  ...bind io:monad getc \optchr ..optchr
    \chr .....equal u8:eq '!'u8 chr
      ..pure io:appl nil
      ...fmap io:ftor .cons chr getbang
    ..pure io:appl nil
\getbang

# bfp :: Parser (Tape -> IO Tape)
# all the component parsers also have this type. this way, juxtaposition of
# Brainfuck program strings corresponds to `liftA2 (>=>)`, that is, penetration
# of parsers with Kleisli composition
..def .fix \bfp
 ..def ...fmapk parser:ftor
    ..bluebird .pure io:appl tape.shl
    .chrp '>'u8
  \'>'p
 ..def ...fmapk parser:ftor
    ..bluebird .pure io:appl tape.shr
    .chrp '<'u8
  \'<'p
 ..def ...fmapk parser:ftor
    ..bluebird .pure io:appl ..fmap tape:ftor u8.inc
    .chrp '+'u8
  \'+'p
 ..def ...fmapk parser:ftor
    ..bluebird .pure io:appl ..fmap tape:ftor u8.dec
    .chrp '-'u8
  \'-'p
 ..def ...fmapk parser:ftor
    \tape ...fmapk io:ftor
      tape
      .putc .head tape
    .chrp '.'u8
  \'.'p
 ..def ...fmapk parser:ftor
    \tape ...fmap io:ftor
      \optchr ...fmapk tape:ftor ..optchr id '\0'u8 tape
      getc
    .chrp ','u8
  \','p
 ..def ...fmap parser:ftor
    \bf .fix \rec \tape
      ......equal u8:eq '\0'u8 .head tape
        .pure io:appl
        ...kleisli io:monad bf rec
      tape
    ....between parser:appl .chrp '['u8 .chrp ']'u8 bfp
  \[&]p
 ..def ...fmapk parser:ftor
    .pure io:appl
    .satp ...phi and ..unequal u8:eq '['u8 ..unequal u8:eq ']'u8
  \![]p

 ..def
    ...alt parser:altn ![]p
    ...alt parser:altn [&]p
    ...alt parser:altn ','p
    ...alt parser:altn '.'p
    ...alt parser:altn '-'p
    ...alt parser:altn '+'p
    ...alt parser:altn '<'p
    ...alt parser:altn '>'p
    .empty parser:altn
  \atomp
  # bfp = liftA2 (>=>) atomp bfp <|> pure pure
  ...alt parser:altn
    ..pure parser:appl .pure io:appl
    ....lifta2 parser:appl .kleisli io:monad atomp bfp
\bfp

.main
  ...bind io:monad getbang \str
    ......seql parser:appl bfp eofp str
      \proginp .proginp \prog \inp .prog 0tape
      ...bindk io:monad .putc '!'u8 .putc '\n'u8

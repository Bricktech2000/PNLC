# vim:tw=80:ft=pnlc:
# inc:../prelude.pnlc

# data Tape = Tape (Stream U8) U8 (Stream U8) -- where:
# type Stream a = Fix (Pair a) -- where:
# data Fix f = Fix (f (Fix f))
..def \left \head \right \tape ...tape left head right \tape
..def \tape .tape \left \head \right left \left
..def \tape .tape \left \head \right head \head
..def \tape .tape \left \head \right right \right
# apply `func` to the `head`
..def .ftor
  \func \tape .tape \left \head \right \tape
    ...tape left .func head right
\tape:ftor
# an infinite tape of zeroes
..def ...tape
  .fix .pair '\0'u8
  '\0'u8
  .fix .pair '\0'u8
\0tape
..def \tape .tape \left \head \right \tape .right \fst \snd
  ...tape ..pair head left fst snd
\tape.shl
..def \tape .tape \left \head \right \tape .left \fst \snd
  ...tape snd fst ..pair head right
\tape.shr

# read characters from stdin until a '!'. we use the character '!' to separate
# the Brainfuck program from its input. that is, '!' ends a program string and
# and begins its execution
..def .fix \getbang
  ...bind io:mnad getc ..vireo
    \chr .....equal u8:eq '!'u8 chr
      ..pure io:aptv nil
      ...fmap io:ftor .cons chr getbang
    ..pure io:aptv nil
\getbang

# bfp :: Parser (Tape -> IO Tape)
# all the component parsers also have this type. this way, juxtaposition of
# Brainfuck program strings corresponds to `liftA2 (>=>)`, that is, penetration
# of parsers with Kleisli composition
..def .fix \bfp
 ..def ...fmapk parser:ftor
    ..bluebird .pure io:aptv tape.shl
    .chrp '>'u8
  \'>'p
 ..def ...fmapk parser:ftor
    ..bluebird .pure io:aptv tape.shr
    .chrp '<'u8
  \'<'p
 ..def ...fmapk parser:ftor
    ..bluebird .pure io:aptv ..fmap tape:ftor u8.inc
    .chrp '+'u8
  \'+'p
 ..def ...fmapk parser:ftor
    ..bluebird .pure io:aptv ..fmap tape:ftor u8.dec
    .chrp '-'u8
  \'-'p
 ..def ...fmapk parser:ftor
    \tape ...fmapk io:ftor
      tape
      .putc .head tape
    .chrp '.'u8
  \'.'p
 ..def ...fmapk parser:ftor
    \tape ...fmap io:ftor
      \optchr ...fmapk tape:ftor ..optchr id '\0'u8 tape
      getc
    .chrp ','u8
  \','p
 ..def ...fmap parser:ftor
    \bf .fix \rec \tape
      ......equal u8:eq '\0'u8 .head tape
        .pure io:aptv
        ...kleisli io:mnad bf rec
      tape
    ....between parser:aptv .chrp '['u8 .chrp ']'u8 bfp
  \[&]p
 ..def ...fmapk parser:ftor
    .pure io:aptv
    .satp ...phi and ..unequal u8:eq '['u8 ..unequal u8:eq ']'u8
  \![]p

 ..def
    ...alt parser:altv ![]p
    ...alt parser:altv [&]p
    ...alt parser:altv ','p
    ...alt parser:altv '.'p
    ...alt parser:altv '-'p
    ...alt parser:altv '+'p
    ...alt parser:altv '<'p
    ...alt parser:altv '>'p
    .empty parser:altv
  \atomp
  # bfp = liftA2 (>=>) atomp bfp <|> pure pure
  ...alt parser:altv
    ..pure parser:aptv .pure io:aptv
    ....lifta2 parser:aptv .kleisli io:mnad atomp bfp
\bfp

.main
  ...bind io:mnad getbang \str
    ......seql parser:aptv bfp eofp str
      .thrush \prog \inp .prog 0tape
      ...seqr io:aptv .putc '!'u8 .putc '\n'u8

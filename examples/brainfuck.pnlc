# vim:tw=80:ft=pnlc:
# inc:../prelude.pnlc

# data Tape = Tape (Stream U8) U8 (Stream U8) -- where:
# type Stream a = Fix (Pair a) -- where:
# data Fix f = Fix (f (Fix f))
.\left \head \right \tape .right .head .left tape \tape
.\tape .\left \head \right left tape \left
.\tape .\left \head \right head tape \head
.\tape .\left \head \right right tape \right
# apply `func` to the `head`
  ..\func \tape
    .\left \head \right \tape
      .right ..head func .left tape
    tape
  ftor
\tape:ftor
# an infinite tape of zeroes
  ....'\0'u8 pair fix
  .'\0'u8
  ...'\0'u8 pair fix
  tape
\0tape
.\tape
  .\left \head \right \tape
    .\fst \snd
      .snd .fst ..left .head pair tape
    right
  tape
\tape.shl
.\tape
  .\left \head \right \tape
    .\fst \snd
      ..right .head pair .fst .snd tape
    left
  tape
\tape.shr

# read characters from stdin until a '!'. we use the character '!' to separate
# the Brainfuck program from its input. that is, '!' ends a program string and
# and begins its execution
..\getbang
  .\optchr
    ..nil .io:appl pure
    .\chr
      ..getbang ..chr cons .io:ftor fmap
      ..nil .io:appl pure
      .chr .'!'u8 .u8:eq equal
    optchr
  .getc
  .io:monad bind
fix \getbang

# bfp :: Parser (Tape -> IO Tape)
# all the component parsers also have this type. this way, juxtaposition of
# Brainfuck program strings corresponds to `liftA2 (>=>)`, that is, penetration
# of parsers with Kleisli composition
..\bfp
    ...'>'u8 chrp
    ..tape.shl ..io:appl pure bluebird
    .parser:ftor fmapk
  \'>'p
    ...'<'u8 chrp
    ..tape.shr ..io:appl pure bluebird
    .parser:ftor fmapk
  \'<'p
    ...'+'u8 chrp
    ...u8.inc .tape:ftor fmap ..io:appl pure bluebird
    .parser:ftor fmapk
  \'+'p
    ...'-'u8 chrp
    ...u8.dec .tape:ftor fmap ..io:appl pure bluebird
    .parser:ftor fmapk
  \'-'p
    ...'.'u8 chrp
    .\tape
      ...tape head putc
      .tape
      .io:ftor fmapk
    .parser:ftor fmapk
  \'.'p
    ...','u8 chrp
    .\tape
      .getc
      .\optchr .tape ..'\0'u8 .id optchr .tape:ftor fmapk
      .io:ftor fmap
    .parser:ftor fmapk
  \','p
    ...bfp ..']'u8 chrp ..'['u8 chrp .parser:appl between
    .\bf .\rec \tape
      .tape
      ..rec .bf .io:monad kleisli
      ..io:appl pure
      ..tape head .'\0'u8 .u8:eq equal
    fix .parser:ftor fmap
  \[&]p
    .....']'u8 .u8:eq unequal ..'['u8 .u8:eq unequal .and phi satp
    ..io:appl pure
    .parser:ftor fmapk
  \![]p

    ..........parser:altn empty
    .'>'p .parser:altn alt
    .'<'p .parser:altn alt
    .'+'p .parser:altn alt
    .'-'p .parser:altn alt
    .'.'p .parser:altn alt
    .','p .parser:altn alt
    .[&]p .parser:altn alt
    .![]p .parser:altn alt
  \atomp
  # bfp = liftA2 (>=>) atomp bfp <|> pure pure
  ..bfp .atomp ..io:monad kleisli .parser:appl lifta2
  ...io:appl pure .parser:appl pure
  .parser:altn alt
fix \bfp

  ..\str
    ...'\n'u8 putc ..'!'u8 putc .io:monad bindk
    .\proginp .\prog \inp .0tape prog proginp
    .str .eofp .bfp .parser:appl seql
  .getbang
  .io:monad bind
main
